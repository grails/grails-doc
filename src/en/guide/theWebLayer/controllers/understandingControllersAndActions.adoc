
==== Creating a controller


Controllers can be created with the link:../ref/Command%20Line/create-controller.html[create-controller] or link:../ref/Command%20Line/generate-controller.html[generate-controller] command. For example try running the following command from the root of a Grails project:

[source,java]
----
grails create-controller book
----

The command will create a controller at the location `grails-app/controllers/myapp/BookController.groovy`:

[source,java]
----
package myapp

class BookController {

    def index() { }
}
----

where "myapp" will be the name of your application, the default package name if one isn't specified.

`BookController` by default maps to the /book URI (relative to your application root).

NOTE: The `create-controller` and `generate-controller` commands are just for convenience and you can just as easily create controllers using your favorite text editor or IDE


==== Creating Actions


A controller can have multiple public action methods; each one maps to a URI:

[source,java]
----
class BookController {

    def list() {

        // do controller logic
        // create model

        return model
    }
}
----

This example maps to the `/book/list` URI by default thanks to the property being named `list`.


==== Public Methods as Actions


In earlier versions of Grails actions were implemented with Closures. This is still supported, but the preferred approach is to use methods.

Leveraging methods instead of Closure properties has some advantages:
* Memory efficient
* Allow use of stateless controllers (`singleton` scope)
* You can override actions from subclasses and call the overridden superclass method with `super.actionName()`
* Methods can be intercepted with standard proxying mechanisms, something that is complicated to do with Closures since they're fields.

If you prefer the Closure syntax or have older controller classes created in earlier versions of Grails and still want the advantages of using methods, you can set the `grails.compile.artefacts.closures.convert` property to true in `application.yml`:
[source,groovy]
----
grails:
    compile:
        artefacts:
            closures:
                convert: true
----

and a compile-time AST transformation will convert your Closures to methods in the generated bytecode.

NOTE: If a controller class extends some other class which is not defined under the `grails-app/controllers/` directory, methods inherited from that class are not converted to controller actions.  If the intent is to expose those inherited methods as controller actions the methods may be overridden in the subclass and the subclass method may invoke the method in the super class.


==== The Default Action


A controller has the concept of a default URI that maps to the root URI of the controller, for example `/book` for `BookController`. The action that is called when the default URI is requested is dictated by the following rules:

* If there is only one action, it's the default
* If you have an action named `index`, it's the default
* Alternatively you can set it explicitly with the `defaultAction` property:

[source,java]
----
static defaultAction = "list"
----
