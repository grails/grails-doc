Beyond the specific targeted mocking APIs there is also an all-purpose @mockFor()@ method that is available when using the @TestFor@ annotation. The signature of @mockFor@ is:

{code:java}
mockFor(class, loose = false)
{code}

This is general-purpose mocking that lets you set up either strict or loose demands on a class.

This method is surprisingly intuitive to use. By default it will create a strict mock control object (one for which the order in which methods are called is important) that you can use to specify demands:

{code:java}

def strictControl = mockFor(MyService)
strictControl.demand.someMethod(0..2) { String arg1, int arg2 -> ... }
strictControl.demand.static.aStaticMethod {-> ... }
{code}

Notice that you can mock static as well as instance methods by using the "static" property. You then specify the name of the method to mock, with an optional range argument. This range determines how many times you expect the method to be called, and if the number of invocations falls outside of that range (either too few or too many) then an assertion error will be thrown. If no range is specified, a default of "1..1" is assumed, i.e. that the method must be called exactly once.

The last part of a demand is a closure representing the implementation of the mock method. The closure arguments must match the number and types of the mocked method, but otherwise you are free to add whatever you want in the body.

Call @mockControl.createMock()@ to get an actual mock instance of the class that you are mocking. You can call this multiple times to create as many mock instances as you need. And once you have executed the test method, call @mockControl.verify()@ to check that the expected methods were called.

Grails mocks also provide a @demandExplicit@ method that can be used in place of demand.  This will check the mocked class's metaClass and throw an ExplicitDemandException if a method with that name and signature doesn't exist. For example, given the service:

{code:java}
class MyService {
    def someMethod(String s) { ... }
}
{code}

The following mocking works the same as demand
{code:java}
def strictControl = mockFor(MyService)
//Works just like the demand method since method signature exists on the class
strictControl.demandExplicit.someMethod(1) { String arg1  }
{code}

While this mocking throws an ExplicitDemandException when the test is run.
{code:java}
def strictControl = mockFor(MyService)
//Throws ExplicitDemandException because method signature doesn't exist
strictControl.demandExplicit.someMethod(1) { String arg1, String arg2  }
{code}

Using demandExplicit should be the preferred method for mocking as it is more likely to catch issues when changing method signatures.  Use demand when the method to be mocked is added dynamically, otherwise use demandExplicit.

Lastly, the call:

{code:java}
def looseControl = mockFor(MyService, true)
{code}

will create a mock control object that has only loose expectations, i.e. the order that methods are invoked does not matter.
