Since Grails is built on Java technology setting up a data source requires some knowledge of JDBC (the technology that doesn't stand for Java Database Connectivity).

If you use a database other than H2 you need a JDBC driver. For example for MySQL you would need "Connector/J":http://www.mysql.com/downloads/connector/j/

Drivers typically come in the form of a JAR archive. It's best to use Ivy to resolve the jar if it's available in a Maven repository, for example you could add a dependency for the MySQL driver like this:

{code}
grails.project.dependency.resolution = {
    inherits("global")
    log "warn"
    repositories {
        grailsPlugins()
        grailsHome()
        grailsCentral()
        mavenCentral()
    }
    dependencies {
        runtime 'mysql:mysql-connector-java:5.1.16'
    }
}
{code}

Note that the built-in @mavenCentral()@ repository is included here since that's a reliable location for this library.

If you can't use Ivy then just put the JAR in your project's @lib@ directory.

Once you have the JAR resolved you need to get familiar Grails' DataSource descriptor file located at @grails-app/conf/DataSource.groovy@. This file contains the dataSource definition which includes the following settings:

* @driverClassName@ - The class name of the JDBC driver
* @username@ - The username used to establish a JDBC connection
* @password@ - The password used to establish a JDBC connection
* @url@ - The JDBC URL of the database
* @dbCreate@ - Whether to auto-generate the database from the domain model - one of 'create-drop', 'create', 'update' or 'validate'
* @pooled@ - Whether to use a pool of connections (defaults to true)
* @logSql@ - Enable SQL logging to stdout
* @formatSql@ - Format logged SQL
* @dialect@ - A String or Class that represents the Hibernate dialect used to communicate with the database. See the [org.hibernate.dialect|http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/dialect/package-summary.html] package for available dialects.
* @readOnly@ - If @true@ makes the DataSource read-only, which results in the connection pool calling @setReadOnly(true)@ on each @Connection@
* @persistenceInterceptor@ - The default datasource is automatically wired up to the persistence interceptor, other datasources are not wired up automatically unless this is set to @true@
* @properties@ - Extra properties to set on the DataSource bean. See the [Commons DBCP BasicDataSource|http://commons.apache.org/dbcp/api-1.2.2/org/apache/commons/dbcp/BasicDataSource.html] documentation.

A typical configuration for MySQL may be something like:

{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost/yourDB"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "yourUser"
    password = "yourPassword"
}
{code}

{warning}
When configuring the DataSource do not include the type or the def keyword before any of the configuration settings as Groovy will treat these as local variable definitions and they will not be processed. For example the following is invalid:
{warning}

{code:java}
dataSource {
    boolean pooled = true // type declaration results in ignored local variable
    ...
}
{code}

Example of advanced configuration using extra properties:
{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost/yourDB"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "yourUser"
    password = "yourPassword"
    properties {
        maxActive = 50
        maxIdle = 25
        minIdle = 5
        initialSize = 5
        minEvictableIdleTimeMillis = 60000
        timeBetweenEvictionRunsMillis = 60000
        maxWait = 10000
        validationQuery = "/* ping */"
    }
}
{code}

h4. More on dbCreate

Hibernate can automatically create the database tables required for your domain model. You have some control over when and how it does this through the @dbCreate@ property, which can take these values:

* *create* - Drops the existing schemaCreates the schema on startup, dropping existing tables, indexes, etc. first.
* *create-drop* - Same as *create*, but also drops the tables when the application shuts down cleanly.
* *update* - Creates missing tables and indexes, and updates the current schema without dropping any tables or data. Note that this can't properly handle many schema changes like column renames (you're left with the old column containing the existing data).
* *validate* - Makes no changes to your database. Compares the configuration with the existing database schema and reports warnings.
* any other value - does nothing

You can also remove the @dbCreate@ setting completely, which is recommended once your schema is relatively stable and definitely when your application and database are deployed in production. Database changes are then managed through proper migrations, either with SQL scripts or a migration tool like [Liquibase|http://www.liquibase.org/] (the "Database Migration":http://grails.org/plugin/database-migration plugin uses Liquibase and is tightly integrated with Grails and GORM).
