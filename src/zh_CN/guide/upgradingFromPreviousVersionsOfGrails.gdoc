{hidden}
A number of changes need to considered when upgrading your application from Grails 2.2, some of them breaking. Here's a quick list with more detail on each item following after:

* New improved data binding (no Spring property editors)
* Much improved XSS prevention with default HTML encoding
* A new dependency resolution engine
* Must be online to fetch Grails dependencies
* Grails core dependencies rearranged
* Tomcat and Hibernate plugins independently versioned now (breaking!)
* Scaffolding is now a separate plugin
* Spock included by default
* Dependency injection does not work in integration tests by default 
* Forked execution for tests
* Reloading in @run-app@ won't work by default on upgraded apps
* @grails-debug@ doesn't work for forked execution


h4. New Data Binder

There is a new data binding mechanism written from the ground up to meet Grails' needs. If you wish to continue using Spring for data binding then you must set the @grails.databinding.useSpringBinder@ property to @true@ in @grails-app/conf/Config.groovy@

h4. Encoding / Escaping (XSS) Changes

Grails 2.3 includes new features to help prevent XSS attacks. These are enabled by default for new applications, but older applications will require manual intervention. See the section on [Cross Site Scripting (XSS) prevention|guide:xssPrevention] for how to appropriately configure XSS prevention.

h4. Dependency Resolution changes

Although dependency resolution using Ivy is still supported, the default for Grails 2.3 is to use Aether and the Ivy support will not be improved upon going forward. You may wish to consider using Aether instead for your existing applications by setting the following in @grails-app/conf/BuildConfig.groovy@:

{code}
grails.project.dependency.resolver = "maven" // or ivy
{code}

If you need to authenticate to a maven repository, you will want to change the definition of that repository like so:

{code}
mavenRepo("http://artifactory.mycompany.com/repo") {
    authentication(username: "myusername", password: "secret")
}
{code}

h4. Dependency Metadata Changes

In addition, the POM and dependency metadata for Grails 2.3 has been re-arranged and cleaned up so that only direct dependencies are specified for an application and all other dependencies are inherited transitvely. This has implications to the upgrade since, for example, Ehcache is now a transitive dependency of the Hibernate plugin, whilst before it was a direct dependency. If get a compilation error related to Ehcache, it is most likely that you don't have the Hibernate plugin installed and need to directly declare the Ehcache dependency:

{code}
compile "net.sf.ehcache:ehcache-core:2.4.6"
{code}

In addition, excludes may no longer work and may need adjusting when upgrading due to how the metadata has changed. Run the [dependency-report|commandLine] to see the new dependency metadata and make adjustments accordingly.

A common error that may occur when upgrading is:

{code}
| Configuring classpath
:: problems summary ::
:::: WARNINGS
    ::::::::::::::::::::::::::::::::::::::::::::::
    ::          UNRESOLVED DEPENDENCIES         ::
    ::::::::::::::::::::::::::::::::::::::::::::::
    :: org.springframework#spring-test;3.2.2.RELEASE: configuration not found in org.springframework#spring-test;3.2.2.RELEASE: 'compile'. It was required from org.grails#grails-plugin-testing;2.3.0.BUILD-SNAPSHOT compile
    ::::::::::::::::::::::::::::::::::::::::::::::
{code}

This is caused by a plugin that depends on an old version of @spring-test@ (for example the [Mail plugin|http://grails.org/plugins/mail]). To correct this run @grails dependency-report@ and search for plugins that have a transitive dependency on @spring-test@ and exclude them. For example:

{code}
plugins {
  compile ':mail:1.0', {
    excludes 'spring-test'
  }  
}
{code}

However, longer term to solve problems like this we recommend that users move away from Ivy and use Aether instead for dependency resolution:

{code}
grails.project.dependency.resolver="maven"
{code}

h4. No initial offline mode with Aether

Aether does not support resolving dependencies from a flat file system. This means that the jars we ship with Grails in GRAILS_HOME/lib are not used for the first resolve, but instead the jars are obtained from Maven central. After they have been obtained from Maven central then Aether operates fine offline.

If however you do not have the necessary jars in your local Maven repository, then the only way to get offline execution is to enable Ivy via BuildConfig (see above).

h4. Changes to Core plugin versioning schemes and the Upgrade command

Core plugins like @tomcat@ and @hibernate@ are no longer versioned the same as the Grails version, instead they are versioned according to the Tomcat and Hibernate version they target. If you are upgrading from Grails 2.2 you need to manually configure the correct Tomcat and Hibernate plugins in @BuildConfig@. The @upgrade@ command will not do this for you!

{code}
    plugins {
        // plugins for the build system only
        build ':tomcat:7.0.42'

        // plugins needed at runtime but not for compilation
        runtime ':hibernate:3.6.10.2' 
    }
{code}

Note that the @upgrade@ command will be deprecated in 2.3 and replaced with a command named @use-current-grails-version@, which will make no attempts to automatically upgrade Grails applications.

h4. Scaffolding moved to a plugin and rewritten

If you have dynamically scaffolded controllers in your application then you will need to configure the 1.0 version of the [Scaffolding plugin|http://grails.org/plugin/scaffolding] in BuildConfig:

{code}
plugins {
  compile ':scaffolding:1.0.0'
}
{code}

By default for new applications the 2.0 version of the scaffolding plugin is used, which is not backwards compatible with 1.0.

h4. Spock included by default

You no longer need to add the Spock plugin to your projects. Simply create Spock specifications as before and they will be run as unit tests. In fact, don't install the Spock plugin, otherwise your specifications will run twice and potentially fail. This also means that the @spock@ test type no longer exists. Specifications and JUnit tests run as the same type now.

h4. Dependency Injection for Integration Tests

In order to support alternate JUnit4 test runners, Grails 2.3 no longer uses a special test runner to run tests and integration tests should no longer extend @GroovyTestCase@.

This change requires that any JUnit integration tests that require dependency injection now need to be annotated with:

{code}
\@TestMixin(IntegrationTestMixin)
{code}

For Spock integration tests, extending @IntegrationSpec@ also works.

h4. Forked Execution for Testing

Tests are now by default executed in a forked JVM (although this can be disabled). One implication of this is that tests will be slower to execute when using:

{code}
grails test-app
{code}

The reason for this is the need to load a separate JVM to execute tests. To mitigate this Grails interactive mode has been updated to load a background JVM that can be resumed. If you do:

{code}
$ grails // load interactive mode
$ grails -> test-app
$ grails -> test-app
{code}

Test execution will be noticably faster and is the recommended way to run tests in Grails. On older hardware that does not include multiple cores (to run the separate JVMs) it is recommended you disable forked execution for tests to achieve faster test execution times:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: false, // disable forked execution for test-app
   run: forkConfig, // configure settings for the run-app JVM
   ...
]
{code}

h4. Forked Execution and the Reloading Agent

In Grails 2.3 the reloading agent is no longer on the build system path unless you pass the @-reloading@ flag to the @grails@ command:

{code}
grails -reloading run-app
{code}

The reason for this is that the default in Grails 2.3 and above is to load Grails application in a forked JVM and enable the agent for the forked JVM. If you do not wish to use forked JVMs then you must ensure that you run Grails with the @-reloading@ flag. Alternatively, you can enable forking with the following configuration in @BuildConfig@:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: forkConfig, // configure settings for the test-app JVM
   run: forkConfig, // configure settings for the run-app JVM
   war: forkConfig, // configure settings for the run-war JVM
   console: forkConfig // configure settings for the Swing console JVM
]
{code}

h4. Forked Execution and Remote Debugging

The @grails-debug@ command will no longer work with Grails for remote debugging sessions. The reason is the command enabled debugging for the build system JVM, but not the JVM used in forked execution. The solution to this is to use the @debug-fork@ command line argument:

{code}
grails --debug-fork run-app
{code}


Alternatively you can set the @debug@ setting to @true@ in @BuildConfig@ and use the regular @grails@ command to execute:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: true, maxPerm: 256]
grails.project.fork = [
   run: forkConfig, // configure settings for the run-app JVM
   ...
{code}

h4. Forked Execution and Functional Test plugins

Some existing plugins (Cucumber plugin for example) do not work with 2.3.x forked execution because they expect the tests to be running in the same JVM as the application under tests. For example it is not possible to setup fixture / test data using GORM inside a functional test and have that data visible to the application under test since the application under test is in a separate JVM. The solution to this is to provide the necessary fixture data in the @BootStrap@ of the application (only for the test environment of course).
{hidden}
把你的应用程序从Grails 2.2进行升级需要考虑到许多变更，其中的某些变更是破坏性的。下面是简要的列表，每个项目更多的细节在后面说明：

* 新的改进的数据绑定（不使用Spring属性编辑器）
* 使用默认HTML编码的大大改进的XSS攻击防御
* 一个新的依赖解析引擎
* 获取Grails依赖时必须联网
* 重新调整的Grails核心依赖
* Tomcat插件和Hibernate插件的版本现在互相独立（破坏性！）
* 脚手架现在成为独立的插件
* 默认包含Spock
* 集成测试中依赖注入默认不起作用
* 测试运行时的分叉执行
* 对升级后的应用程序@run-app@默认不进行重新加载
* @grails-debug@不会分叉执行

h4. 新的数据绑定器

为了满足Grails的需要重头编写了新的数据绑定机制。如果你希望继续使用Spring的数据绑定技术，那么你必须在@grails-app/conf/Config.groovy@中把@grails.databinding.useSpringBinder@ 属性设置为@true@

h4. 编码/转义(XSS)等的变更

Grails包含了帮助防止XSS攻击的新功能。这些新功能对新创建的应用程序默认启用，但是旧应用程序将需要手工干预。参考有关[防止XSS攻击|guide:xssPrevention]的章节了解如何合适地配置XSS防御。

h4. 依赖解析的变更

尽管仍然支持使用Ivy进行依赖解析，Grails 2.3默认使用Aether并且以后不会对Ivy支持进行改进。你可能希望对你现有的应用程序使用Aether，方法是在@grails-app/conf/BuildConfig.groovy@中进行如下的设置：

{code}
grails.project.dependency.resolver = "maven" // or ivy
{code}

如果你需要向一个Maven仓库进行认证，你要按如下方式改变仓库的定义：

{code}
mavenRepo("http://artifactory.mycompany.com/repo") {
    authentication(username: "myusername", password: "secret")
}
{code}

h4. 依赖元数据的变更

此外，Grails中POM和依赖元数据也已经重新调整和清理过使得只要指定直接依赖并且所有其他的依赖被传递地继承。这会对升级产生影响，因为例如Ehcache现在是Hibernate插件的传递依赖，而之前它是一个直接依赖。如果你得到一个有关于Ehcache的编译错误，最可能的原因是你没有安装Hibernate插件，因此需要直接声明Ehcache依赖：

{code}
compile "net.sf.ehcache:ehcache-core:2.4.6"
{code}

此外，由于元数据已经变更，依赖排除可能会不起作用并且可能需要进行调整。运行[dependency-report|commandLine]来查看新的依赖元数据并据此进行调整。

升级时常发生的常见错误是：

{code}
| Configuring classpath
:: problems summary ::
:::: WARNINGS
    ::::::::::::::::::::::::::::::::::::::::::::::
    ::          UNRESOLVED DEPENDENCIES         ::
    ::::::::::::::::::::::::::::::::::::::::::::::
    :: org.springframework#spring-test;3.2.2.RELEASE: configuration not found in org.springframework#spring-test;3.2.2.RELEASE: 'compile'. It was required from org.grails#grails-plugin-testing;2.3.0.BUILD-SNAPSHOT compile
    ::::::::::::::::::::::::::::::::::::::::::::::
{code}

这是由一个依赖@spring-test@老版本的插件（例如[邮件插件|http://grails.org/plugins/mail]）引起的。为了更正这个错误运行@grails dependency-report@命令并搜索对@spring-test@有传递依赖的插件并且排除他们，例如：

{code}
plugins {
  compile ':mail:1.0', {
    excludes 'spring-test'
  }  
}
{code}

但是，更长远的解决类似问题的方式是我们推荐用户从Ivy转移至Aether进行依赖解析：

{code}
grails.project.dependency.resolver="maven"
{code}

h4. 使用Aether时不再是初始的离线模式

Aether不支持从扁平文件系统对依赖解析。这意味着与Grails一同发布的GRAILS_HOME/lib下的jar文件不再用于第一次的依赖解析，取而代之的是从Maven中央仓库得到jar文件。在从Maven中央仓库得到jar文件后Aether可以在离线模式下运行良好。

如果你还是不需要本地Maven仓库中必要的jar文件的话，那么离线执行的唯一方式是在BuildConfig中启用Ivy（见上面的说明）。

h4. 核心插件版本管理方案的变更和upgrade命令

像@tomcat@和@hibernate@这样的核心插件不再和Grails使用相同的版本号，取而代之的是他们按照他们针对的Tomcat或Hibernate的版本定义版本号。如果你正在从Grails 2.2进行升级的话你需要在@BuildConfig@中手工配置正确的Tomcat和Hibernate插件版本。@upgrade@命令不会帮你完整这件事！

{code}
    plugins {
        // 仅构建系统需要的插件
        build ':tomcat:7.0.42'

        // 运行时需要但编译时不需要的插件
        runtime ':hibernate:3.6.10.2' 
    }
{code}

注意在Grails 2.3中@upgrade@命令不被推荐使用并且使用名为@use-current-grails-version@的命令代替它，该命令不再试图自动升级Grails应用程序。

h4. 脚手架变为一个插件并且被重新改写

如果在你的应用程序中你有动态脚手架化的控制器，那么你需要在BuildConfig配置1.0版本的[脚手架插件|http://grails.org/plugin/scaffolding]：

{code}
plugins {
  compile ':scaffolding:1.0.0'
}
{code}

默认新创建的应用程序使用2.0版本的脚手架插件，其与1.0版本不向后兼容。

h4. 默认包含Spock

你不再需要添加Spock插件到你的项目中了。只要像以前一样创建Spock规格说明它们就可以作为单元测试运行。事实上，不要安装spock插件，否则你的规格说明将会运行两次而且有失败的可能性。这也意味着@spock@测试类型不再存在。现在规格说明和JUnit测试以相同的类型运行。

h4. 用于集成测试的依赖注入

为了支持其他的JUnit4测试运行器，Grails 2.3不再使用一个特殊的测试运行器运行测试并且集成测试将不再派生自@GroovyTestCase@类。

这个变更要求任何使用依赖注入的集成测试现在需要使用下面的注解进行声明：

{code}
\@TestMixin(IntegrationTestMixin)
{code}

对于Spock集成测试，派生自@IntegrationSpec@也行。

h4. 测试的分叉执行

现在测试默认在分叉出的JVM中执行（尽管可以禁用分叉执行）。这样的影响是使用下面的方法测试将会执行得更慢：

{code}
grails test-app
{code}

原因是这样做需要加载独立的JVM执行测试。为了缓解这个问题Grails交互模式已经进行了更新，加载一个可以被继续执行的后台JVM。如果你执行：

{code}
$ grails // 载入交互模式
$ grails -> test-app
$ grails -> test-app
{code}

测试执行将会显著变快而且这是在Grails中运行测试的推荐方法。在不包括多核的较老的硬件上（运行多个独立的JVM）推荐你为测试禁用分叉执行以取得更快的测试执行时间：

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: false, // 为test-app禁用分叉执行
   run: forkConfig, // 用于run-app的JVM的配置设定
   ...
]
{code}

h4. 分叉执行和重新加载代理

在Grails 2.3中重新加载代理不再位于构建系统的路径里，除非你把@-reloading@标志传递到@grails@命令：

{code}
grails -reloading run-app
{code}

这样做的原因是因为Grails 2.3中默认在分叉出的JVM中加载Grails应用程序并且对分叉出的JVM启用了这个代理。如果你不愿意使用分叉出的JVM的话，那么你必须确保使用@-reloading@标志运行Grails。你也可以在@BuildConfig@中使用下面的配置启用分叉执行：

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: forkConfig, // test-app JVM的配置设定
   run: forkConfig, // run-app JVM的配置设定
   war: forkConfig, // run-war JVM的配置设定
   console: forkConfig // Swing控制台JVM的配置设定
]
{code}

h4. 分叉执行和远程调试

@grails-debug@不再用于Grails的远程调试会话。原因是这个命令对构建系统JVM启用了调试，而不是对分叉执行的JVM。解决方法是使用@debug-fork@命令行参数：

{code}
grails --debug-fork run-app
{code}

你也可以@BuildConfig@在中设置@debug@为@true@并使用通常的@grails@命令执行：

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: true, maxPerm: 256]
grails.project.fork = [
   run: forkConfig, // run-app JVM的配置设定
   ...
{code}

h4. 分叉执行和功能测试插件

某些现有的插件（例如Cucumber插件）不能和2.3.x的分叉执行一起工作，因为它们期望测试和测试的应用程序运行在系统的JVM中。例如，不能在功能测试中使用GORM设置Fixture数据或测试数据并且让这些数据在测试中的应用程序可见，因为测试中的应用程序运行于一个独立的JVM中。这个问题的解决方法是在应用程序的@BootStrap@中提供必要的Fixture数据（当然是只针对测试环境）。
