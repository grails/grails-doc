h4. Sets 对象

当你使用GORM定义了关联后，它将使用无序的 @java.util.Set@ 集合，同时它也是无重复的:

{code}
class Author {
    static hasMany = [books: Book]
}
{code}

books属性将被注入在@java.util.Set@中。Sets是不排序的，这个可能不是你想要的。为了得到排序结果，你需要设置 @SortedSet@:

{code}
class Author {

    SortedSet books

    static hasMany = [books: Book]
}
{code}

@java.util.SortedSet@意味着你的Book类也必须实现 @java.lang.Comparable@ :

{code}
class Book implements Comparable {

    String title
    Date releaseDate = new Date()

    int compareTo(obj) {
        releaseDate.compareTo(obj.releaseDate)
    }
}
{code}

以上的Book实例中的Author类将由它的Release date来实现排序。

h4. Lists 对象

为了让对象按照它们被添加的顺序，并能够通过索引引用它们，就像你定义集合类型为@List@数组：

{code}
class Author {

    List books

    static hasMany = [books: Book]
}
{code}

在这种情况下，当你添加新元素到books集合去，它将保存在一个从0索引的顺序列表，你可以这样做：

{code}
author.books[0] // get the first book
{code}

这个方式是由Gibernate在数据库层面上建立一个@books_idx@字段实现元素的索引保存。使用@List@, 元素必须在保存前加入到集合中，否则Hibernate将报错 (@org.hibernate.HibernateException@: null index column for collection):

{code}
// This won't work!
def book = new Book(title: 'The Shining')
book.save()
author.addToBooks(book)

// Do it this way instead.
def book = new Book(title: 'Misery')
author.addToBooks(book)
author.save()
{code}

h4. 对象 Hibernate bags

如果不关心排序和唯一性(或者你自己来实现)，那么你可以使用 Hibernate [Bag|http://docs.jboss.org/hibernate/core/3.6/reference/en-US/html/collections.html] 类型来代表集合.

你只需要定义那个集合类为@Collection@:

{code}
class Author {

   Collection books

   static hasMany = [books: Book]
}
{code}

这样Hibernate就不再管理唯一性和排序，作为包方式实现，从集合中加入或移出它都不会触发已经存在的数据库实例。这样做，你会有比使用 @Set@ 或 @List@ 更好的性能和较少的内存。

h4. Maps 对象

如果你要一个简单string/value列表，你可以这样：

{code}
class Author {
    Map books // map of ISBN:book names
}

def a = new Author()
a.books = ["1590597583":"Grails Book"]
a.save()
{code}
作为Map的键和值必须为Strings类型。

如果你要的是Map对象：

{code}
class Book {

    Map authors

    static hasMany = [authors: Author]
}

def a = new Author(name:"Stephen King")

def book = new Book()
book.authors = [stephen:a]
book.save()
{code}

@hasMany@属性可以定义为内建的Map元素。它的*键*必须为Strings。

h4. 留意集合类型和其性能

Java的@Set@类型不允许重复。为了实现唯一性，当加入一个以@Set@方式关联，Hibernate不得不对数据库加载完整的关联。如果你有一个非常大数量的关联，它浪费影响大量性能。

同样的情况也适用于@List@类型，它为了排序也这样做。因此建议在一个可能遇到大量记录作为关联时，你设置双向关联，以便于可以反向建立它，避免自动整体排序。例如：

{code:java}
def book = new Book(title:"New Grails Book")
def author = Author.get(1)
book.author = author
book.save()
{code}

这个例子中，建立是由子类(Book)来实现的，所以它不需要管理集合，从而得到更少查询和好的代码。在一个@Author@含有大量关联@Book@的实例下，在一下的例子中就能看到对性能的影响了：

{code:java}
def book = new Book(title:"New Grails Book")
def author = Author.get(1)
author.addToBooks(book)
author.save()
{code}

此时，你应该使用 Hibernate Bag 来作为模型的集合。
