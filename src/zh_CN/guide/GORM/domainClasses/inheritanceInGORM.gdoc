GORM支持继承，无论是从抽象基类和具体的持久化GORM实体。

{code}
class Content {
     String author
}
{code}

{code}
class BlogEntry extends Content {
    URL url
}
{code}

{code}
class Book extends Content {
    String ISBN
}
{code}

{code}
class PodCast extends Content {
    byte[] audioStream
}
{code}

上面的例子中，我们有个父类以及它的一系列子类使得它用于更多的特征。

h4. 注意事项

Grails默认使用表单层结构(table-per-hierarchy)映射，依据@class@类名作为可区分字段作为父类(@Content@)以及它的子类(@BlogEntry@, @Book@ ..)，共享*相同*的表。

表单层结构(table-per-hierarchy)映射不允许下层使用不为空non-nullable字段作为继承。 此外，使用表单层结构(table-per-hierarchy)具体开启哪些可以参阅 [ORM DSL|guide:ormdsl]

无论如何，使用继承和表单层结构(table-per-hierarchy)将对性能有所影响(join)。所以我们的建议是你如果打算使用继承，你就不能过于随意以及不得继承太深。

h4. 多态查询

继承的结果是，你能多态查询的能力。例如，使用在 @Content@ 类使用 [list|domainClasses] 方法，将返回所有@Content@子类：

{code}
def content = Content.list() // 列出所有 blog entries, books and podcasts | list all blog entries, books and podcasts
content = Content.findAllByAuthor('Joe Bloggs') // 按照author来查询 | find all by author

def podCasts = PodCast.list() // 只有podcasts类数据 | list only podcasts
{code}