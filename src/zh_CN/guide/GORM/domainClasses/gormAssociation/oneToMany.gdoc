一对多关联是指一个类，例如 @Author@，需要含有多个其他类，例如 @Book@。Grails通过你定义一个 @hasMany@来设定：

{code}
class Author {
    static hasMany = [books: Book]

    String name
}
{code}

{code}
class Book {
    String title
}
{code}

这里你将含有一个单项的一对多。Grails默认将Join的表通过Map的方式读取出来。

{note}
[ORM DSL|guide:ormdsl] 允许使用一个外键的方式映射到Map中。
{note}

Grails将自动基于@hasMany@的设置，将领域类注入到@java.util.Set@中。你可以通过一个集合来使用：

{code}
def a = Author.get(1)

for (book in a.books) {
    println book.title
}
{code}

{note}
Grails默认按照惰性方式来调用，也就是你第一次使用到这个集合时，它才会去读取。如果你不够仔细，可能会遇到这样的问题 [n+1 problem|http://www.javalobby.org/java/forums/t20533.html]。
如果你希望"立即 eager"获取，你可以使用 [ORM DSL|guide:ormdsl] 或者 在 [query|guide:querying] 中加入特殊设置。
{note}

默认时保存和修改将关联这个特征，但删除仅限于 @belongsTo@ 这个特征：

{code}
class Author {
    static hasMany = [books: Book]

    String name
}
{code}

{code}
class Book {
    static belongsTo = [author: Author]
    String title
}
{code}

如果你在一对多中多的对象中含有多个需要一对多的字段，你不得不加入 @mappedBy@ 这个属性指定字段。

{code}
class Airport {
    static hasMany = [flights: Flight]
    static mappedBy = [flights: "departureAirport"]
}
{code}

{code}
class Flight {
    Airport departureAirport
    Airport destinationAirport
}
{code}

在多的侧有针对不同属性含有的多个集合也是可以的。

{code}
class Airport {
    static hasMany = [outboundFlights: Flight, inboundFlights: Flight]
    static mappedBy = [outboundFlights: "departureAirport",
                       inboundFlights: "destinationAirport"]
}
{code}

{code}
class Flight {
    Airport departureAirport
    Airport destinationAirport
}
{code}

