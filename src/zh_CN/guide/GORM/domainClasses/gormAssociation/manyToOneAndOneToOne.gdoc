多对一是最简单一种类型，它通过属性类型到另外一个领域类来实行。介绍一个例子：

h5. Example A

{code}
class Face {
    Nose nose
}
{code}

{code}
class Nose {
}
{code}

以上我们将多对一的关联设定给 @Face@ 对 @Nose@。如果要做双向的关联，那么情况下面：

h5. Example B

{code}
class Face {
    Nose nose
}
{code}

{code}
class Nose {
    static belongsTo = [face:Face]
}
{code}

我们使用 @belongsTo@ 设置来将 @Nose@ 隶属于 @Face。这样使得我们建立一个 @Face@后，将@Nose@实例加入到@Face@中，这样当我们保存或删除@Face@实例时，GORM将自动保存或删除@Nose@。也就是说，保存和删除通过@Face@一并关联到@Nose@：

{code}
new Face(nose:new Nose()).save()
{code}

以上将同时保存 脸和鼻子。注意，这个不是可逆的。反之，将会出现错误：

{code}
new Nose(face:new Face()).save() // will cause an error
{code}

如果删除 @Face@实例，那么@Nose@将同时被删除：

{code}
def f = Face.get(1)
f.delete() // both Face and Nose deleted
{code}

让我们看一下 @hasOne@ 属性给 @Face@ ，将获得什么效果：

h5. Example C

{code}
class Face {
    static hasOne = [nose:Nose]
}
{code}

{code}
class Nose {
    Face face
}
{code}

注意，使用这个属性将和之前那个例子不同，它们的外键(foreign key)放在不同表中。这个例子将在@nose@表中加入一个名为 @face_id@的内建字段。而且， @hasOne@是支持双向关联的。

最后，如果在一对一关联中加入唯一属性是值得的。

{code}
class Face {
    static hasOne = [nose:Nose]

    static constraints = {
        nose unique: true
    }
}
{code}

{code}
class Nose {
    Face face
}
{code}

h5. 控制关联端

Occasionally you may find yourself with domain classes that have multiple properties of the same type. They may even be self-referential, i.e. the association property has the same type as the domain class it's in. Such situations can cause problems because Grails may guess incorrectly the type of the association. Consider this simple class:

{code}
class Person {
    String name
    Person parent

    static belongsTo = [ supervisor: Person ]

    static constraints = { supervisor nullable: true }
}
{code}

As far as Grails is concerned, the @parent@ and @supervisor@ properties are two directions of the same association. So when you set the @parent@ property on a @Person@ instance, Grails will automatically set the @supervisor@ property on the other @Person@ instance. This may be what you want, but if you look at the class, what we in fact have are two unidirectional relationships.

To guide Grails to the correct mapping, you can tell it that a particular association is unidirectional through the @mappedBy@ property:

{code}
class Person {
    String name
    Person parent

    static belongsTo = [ supervisor: Person ]

    static mappedBy = [ supervisor: "none", parent: "none" ]

    static constraints = { supervisor nullable: true }
}
{code}

You can also replace "none" with any property name of the target class. And of course this works for normal domain classes too, not just self-referential ones.  @mappedBy@ 不仅仅可以在 many-to-one 和 one-to-one 中使用关联: 它也可以在 one-to-many 和 many-to-many 使用，下一章节你可以看到这点.

{warning}
如果你正好有个名为"none"的领域类，那么就不能工作了！"none"属性被看做相反的关联(反向引用)。幸运的时，"none"很少作为常用的领域类名属性。
{warning}
