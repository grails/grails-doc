{hidden}
h4. Controller Actions as Methods

It is now possible to define controller actions as methods instead of using closures as in previous versions of Grails. In fact this is now the preferred way of expressing an action. For example:

{code}
// action as a method
def index() {

}
// action as a closure
def index = {

}
{code}

h4. Binding Primitive Method Action Arguments

It is now possible to bind form parameters to action arguments where the name of the form element matches the argument name. For example given the following form:

{code:xml}
<g:form name="myForm" action="save">
    <input name="name" />
    <input name="age" />
</g:form>
{code}

You can define an action that declares arguments for each input and automatically converts the parameters to the appropriate type:

{code}
def save(String name, int age) {
    // remaining
}
{code}

h4. Static Resource Abstraction

A new [static resource abstraction|guide:resources] is included that allows declarative handling of JavaScript, CSS and image resources including automatic ordering, compression, caching and gzip handling.

h4. Servlet 3.0 Async Features

Grails now supports Servlet 3.0 including the Asynchronous programming model defined by the specification:

{code}
def index() {
    def ctx = startAsync()
    ctx.start {
        new Book(title:"The Stand").save()
        render template:"books", model:[books:Book.list()]
        ctx.complete()
    }
}
{code}

h4. Link Generation API

A general purpose @LinkGenerator@ class is now available that is usable anywhere within a Grails application and not just within the context of a controller. For example if you need to generate links in a service or an asynchronous background job outside the scope of a request:

{code}
LinkGenerator grailsLinkGenerator

def generateLink() {
    grailsLinkGenerator.link(controller:"book", action:"list")
}
{code}

h4. Page Rendering API

Like the @LinkGenerator@ the new @PageRenderer@ can be used to render GSP pages outside the scope of a web request, such as in a scheduled job or web service. The @PageRenderer@ class features a very similar API to the @render@ method found within controllers:

{code}
grails.gsp.PageRenderer groovyPageRenderer

void welcomeUser(User user) {
    def contents = groovyPageRenderer.render(view:"/emails/welcomeLetter", model:[user: user])
    sendEmail {
        to user.email
        body contents
    }
}
{code}

The @PageRenderer@ service also allows you to pre-process GSPs into HTML templates:

{code}
new File("/path/to/welcome.html").withWriter { w ->
    groovyPageRenderer.renderTo(view:"/page/content", w)
}
{code}

h4. Filter Exclusions

Filters may now express controller, action and uri exclusions to offer more options for expressing to which requests a particular filter should be applied.

{code}

filter1(actionExclude: 'log*') {
    before = {
        // …
    }
}
filter2(controllerExclude: 'auth') {
    before = {
        // …
    }
}

filter3(uriExclude: '/secure*') {
    before = {
        // …
    }
}
{code}

h4. Performance Improvements

Performance of GSP page rendering has once again been improved by optimizing the GSP compiler to inline method calls where possible.

h4. HTML5 Scaffolding

There is a new HTML5-based scaffolding UI:

!scaffolding-ui.png!

h4. jQuery by Default

The jQuery plugin is now the default JavaScript library installed into a Grails application. For backwards compatibility a [Prototype plugin|http://grails.org/plugin/prototype] is available. Refer to the [documentation|http://grails.org/plugin/prototype] on the Prototype plugin for installation instructions.

h4. Easy Date Parsing

A new @date@ method has been added to the @params@ object to allow easy, null-safe parsing of dates:

{code}
def val = params.date('myDate', 'dd-MM-yyyy')

// or a list for formats
def val = params.date('myDate', ['yyyy-MM-dd', 'yyyyMMdd', 'yyMMdd'])

// or the format read from messages.properties via the key 'date.myDate.format'
def val = params.date('myDate')
{code}

h4. Customizable URL Formats

The default URL Mapping mechanism supports camel case names in the URLs.  The default URL for accessing an action named @addNumbers@ in a controller named @MathHelperController@ would be something like @/mathHelper/addNumbers@.  Grails allows for the customization of this pattern and provides an implementation which replaces the camel case convention with a hyphenated convention that would support URLs like @/math-helper/add-numbers@.  To enable hyphenated URLs assign a value of "hyphenated" to the @grails.web.url.converter@ property in @grails-app/conf/Config.groovy@.

{code:java}
// grails-app/conf/Config.groovy

grails.web.url.converter = 'hyphenated'
{code}

Arbitrary strategies may be plugged in by providing a class which implements the [UrlConverter|api:grails.web.UrlConverter] interface and adding an instance of that class to the Spring application context with the bean name of @grails.web.UrlConverter.BEAN_NAME@.  If Grails finds a bean in the context with that name, it will be used as the default converter and there is no need to assign a value to the @grails.web.url.converter@ config property.

{code:java}
// src/groovy/com/myapplication/MyUrlConverterImpl.groovy

package com.myapplication

class MyUrlConverterImpl implements grails.web.UrlConverter {

    String toUrlElement(String propertyOrClassName) {
        // return some representation of a property or class name that should be used in URLs...
    }
}
{code}

{code:java}
// grails-app/conf/spring/resources.groovy

beans = {
    "\${grails.web.UrlConverter.BEAN_NAME}"(com.myapplication.MyUrlConverterImpl)
}
{code}

h4. Web Flow input and output
It is now possible to provide input arguments when calling a subflow. Flows can also return output values that can be used in a calling flow.
{hidden}
h4. 使用方法定义控制器动作

现在可以把控制器动作定义为方法而不是像以前的Grails版本使用闭包来定义。实际上这也是表示控制器动作优先推荐的方式，比如：

{code}
// 使用方法作为动作
def index() {

}
// 使用闭包作为动作
def index = {

}
{code}

h4. 绑定动作方法中原始类型的参数

现在可以将表单参数跟动作方法参数进行绑定，只要表单元素的名字跟动作方法参数的名字一致即可，以如下的表单为例：

{code:xml}
<g:form name="myForm" action="save">
    <input name="name" />
    <input name="age" />
</g:form>
{code}

你可以定义一个动作方法为每一个输入数据声明对应的参数则会自动将输入参数转换为合适的类型：

{code}
def save(String name, int age) {
    // remaining
}
{code}

h4. 静态资源抽象

新引入的[静态资源抽象|guide:resources]功能允许声明式地对JavaScript、CSS以及图像资源进行自动排序、压缩、缓存和gzip处理。

h4. Servlet 3.0 的异步特性

Grails现在已经支持Servlet 3.0，这包含规范中定义的异步编程模型：

{code}
def index() {
    def ctx = startAsync()
    ctx.start {
        new Book(title:"The Stand").save()
        render template:"books", model:[books:Book.list()]
        ctx.complete()
    }
}
{code}

h4. 超链接生成API

现在有了一个通用的@LinkGenerator@类，可以在Grails应用程序的任何地方使用而不是仅仅在控制器中使用。例如，如果你在请求的作用域外，需要在一个服务组件或者异步运行的后台任务中生成链接：

{code}
LinkGenerator grailsLinkGenerator

def generateLink() {
    grailsLinkGenerator.link(controller:"book", action:"list")
}
{code}

h4. 页面显示API

跟@LinkGenerator@类似，新增的@PageRenderer@能够在web请求的作用域之外的任何地方显示GSP页面，比如被调度的任务或者Web服务中。@PageRenderer@ 类的API跟在控制器中使用的@render@方法非常相似：

{code}
grails.gsp.PageRenderer groovyPageRenderer

void welcomeUser(User user) {
    def contents = groovyPageRenderer.render(view:"/emails/welcomeLetter", model:[user: user])
    sendEmail {
        to user.email
        body contents
    }
}
{code}

@PageRenderer@服务组件还允许你将GSP页面预处理成为HTML模板：

{code}
new File("/path/to/welcome.html").withWriter { w ->
    groovyPageRenderer.renderTo(view:"/page/content", w)
}
{code}

h4. 过滤器的排除

过滤器现在可以表示其排除应用到的控制器、动作和URI，这为一个特定的过滤器可以应用到的请求提供了更多选项。

{code}

filter1(actionExclude: 'log*') {
    before = {
        // …
    }
}
filter2(controllerExclude: 'auth') {
    before = {
        // …
    }
}

filter3(uriExclude: '/secure*') {
    before = {
        // …
    }
}
{code}

h4. 性能改进

通过将GSP编译器在可能的地方进行内联方法调用的优化，使得GSP页面显示性能又一次得到改进。

h4. HTML5脚手架

新增的基于HTML5的脚手架用户界面如下：

!scaffolding-ui.png!

h4. 缺省采用jQuery

jQuery插件已经作为一个缺省的JavaScript库被安装到Grails应用程序中。为了向后兼容，[Prototype插件|http://grails.org/plugin/prototype]仍然可用，其安装指令请参考[Prototype插件文档|http://grails.org/plugin/prototype]。

h4. 易用的日期解析

@params@对象新增了一个@date@方法允许容易地、空指针安全地解析日期：

{code}
def val = params.date('myDate', 'dd-MM-yyyy')

// 或者为日期格式的列表
def val = params.date('myDate', ['yyyy-MM-dd', 'yyyyMMdd', 'yyMMdd'])

// 或者是从messages.properties读取的键为'date.myDate.format'的格式
def val = params.date('myDate')
{code}
