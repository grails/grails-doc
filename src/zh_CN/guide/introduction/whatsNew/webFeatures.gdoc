h4. 使用函数方法来定义控制器的动作

以前Grails的动作只能通过闭包来定义，现在通过一般的函数方法也可以定义了，实际上这也是优先推荐的方式，比如：

{code}
// action as a method
def index() {

}
// action as a closure
def index = {

}
{code}

h4. 自动绑定带参数的动作方法

现在可以将表单（form）参数跟动作参数进行自动匹配了，只要表单下边子元素的名称名字跟参数名称一致即可，以如下的表单为例：

{code:xml}
<g:form name="myForm" action="save">
    <input name="name" />
    <input name="age" />
</g:form>
{code}

你可以定义其动作参数为每一个输入元素的名字，系统会自动将参数值转换为其响应的类型，如以下代码所示：

{code}
def save(String name, int age) {
    // remaining
}
{code}

h4. 静态资源

新引入的静态资源抽象 [static resource abstraction|guide:resources] ，可以声明式地处理JavaScript、CSS以及图像资源的自动排序、压缩、缓存.

h4. Servlet 3.0 的异步特性

Grails现在已经支持Servlet 3.0了，且包含了其规范中定义的异步编程模型，比如：

{code}
def index() {
    def ctx = startAsync()
    ctx.start {
        new Book(title:"The Stand").save()
        render template:"books", model:[books:Book.list()]
        ctx.complete()
    }
}
{code}

h4. 生成超链接的API

在Grails应用，新增的通用 @LinkGenerator@ 类，可以在任何地方生成超链接了，不像以前，只能局限于控制器的上下文中。比如，你要在一个服务或者异步的后台任务等超出web请求范围内使用，可以参考如下代码：

{code}
LinkGenerator grailsLinkGenerator

def generateLink() {
    grailsLinkGenerator.link(controller:"book", action:"list")
}
{code}

h4. 页面渲染API

跟 @LinkGenerator@ 类似，新增的 @PageRenderer@ 能够在超出web请求范围之外的任何地方渲染GSP页面，比如被调度的任务或者WEB服务接口中。 @PageRenderer@  类的API跟在控制器中使用的 @render@ 方法很类似，比如：

{code}
grails.gsp.PageRenderer groovyPageRenderer

void welcomeUser(User user) {
    def contents = groovyPageRenderer.render(view:"/emails/welcomeLetter", model:[user: user])
    sendEmail {
        to user.email
        body contents
    }
}
{code}

@PageRenderer@ 服务还允许你将GSP页面预处理成为HTML模板：

{code}
new File("/path/to/welcome.html").withWriter { w ->
    groovyPageRenderer.renderTo(view:"/page/content", w)
}
{code}

h4. 过滤器的排除

过滤器现在可以明确的指定是排除控制器、动作、还是URI，这为特定请求的过滤器提供了更多选项。

{code}

filter1(actionExclude: 'log*') {
    before = {
        // …
    }
}
filter2(controllerExclude: 'auth') {
    before = {
        // …
    }
}

filter3(uriExclude: '/secure*') {
    before = {
        // …
    }
}
{code}

h4. 性能的提升

通过将GSP编译器优化成内联方法，使得GSP的页面渲染性能又一次得到提升。

h4. HTML5脚手架

新增的基于HTML5的脚手架界面如下：

!scaffolding-ui.png!

h4. jQuery作为缺省JavaScript库

jQuery插件已经作为一个缺省的JavaScript库被安装到Grails应用当中。因为向后兼容的原因，[Prototype plugin|http://grails.org/plugin/prototype] 插件依然是有效的，其安装指令请参考 [documentation|http://grails.org/plugin/prototype] 官方文档。

h4. 易用的日期解析

@params@ 对象新增了一个 @date@ 方法，用以轻松地、空指针安全地解析日期，比如：

{code}
def val = params.date('myDate', 'dd-MM-yyyy')

// or a list for formats
def val = params.date('myDate', ['yyyy-MM-dd', 'yyyyMMdd', 'yyMMdd'])

// or the format read from messages.properties via the key 'date.myDate.format'
def val = params.date('myDate')
{code}

h4. 自定义URL格式

默认的URL链接机制是支持驼峰大小写命名的。在一个类似 @/mathHelper/addNumbers@ 的链接中，它指向一个 @MathHelperController@ 控制器中的 @addNumbers@ 动作。 Grails允许自定义匹配模式来支持将上面的链接不按照驼峰方式来予以实现，而是 @/math-helper/add-numbers@ 的方式。
只要修改 @grails-app/conf/Config.groovy@ ，将 "hyphenated" 的值设置 @grails.web.url.converter@ 属性中即可。

{code:java}
// grails-app/conf/Config.groovy

grails.web.url.converter = 'hyphenated'
{code}

Arbitrary strategies may be plugged in by providing a class which implements the [UrlConverter|api:grails.web.UrlConverter] interface and adding an instance of that class to the Spring application context with the bean name of @grails.web.UrlConverter.BEAN_NAME@.  If Grails finds a bean in the context with that name, it will be used as the default converter and there is no need to assign a value to the @grails.web.url.converter@ config property.

{code:java}
// src/groovy/com/myapplication/MyUrlConverterImpl.groovy

package com.myapplication

class MyUrlConverterImpl implements grails.web.UrlConverter {

    String toUrlElement(String propertyOrClassName) {
        // return some representation of a property or class name that should be used in URLs...
    }
}
{code}

{code:java}
// grails-app/conf/spring/resources.groovy

beans = {
    "\${grails.web.UrlConverter.BEAN_NAME}"(com.myapplication.MyUrlConverterImpl)
}
{code}

h4. Web Flow input and output
It is now possible to provide input arguments when calling a subflow. Flows can also return output values that can be used in a calling flow.
