Grails无疑是一个固执己见框架，并且它喜欢按照约定来进行配置，但这并不意味着你_不能_去配置它。在本章，我们将看到你可以如何去影响和修改标准的Grails构建。

h3. 默认

Grails构建配置的核心就是 @grails.util.BuildSettings@类，它包含了大量有用的信息。它控制了哪些类被编译、应用程序依赖什么以及其他类似的设置。

以下是一个配置选项和它们的默认值的集录：
{table}
*Property* | *Config option* | *Default value*
grailsWorkDir | grails.work.dir | $USER_HOME/.grails/<grailsVersion>
projectWorkDir | grails.project.work.dir | <grailsWorkDir>/projects/<baseDirName>
classesDir | grails.project.class.dir | <projectWorkDir>/classes
testClassesDir | grails.project.test.class.dir | <projectWorkDir>/test-classes
testReportsDir | grails.project.test.reports.dir | <projectWorkDir>/test/reports
resourcesDir | grails.project.resource.dir | <projectWorkDir>/resources
projectPluginsDir | grails.project.plugins.dir | <projectWorkDir>/plugins
globalPluginsDir | grails.global.plugins.dir | <grailsWorkDir>/global-plugins
verboseCompile | grails.project.compile.verbose | @false@
{table}

BuildSettings 类也有一些其他属性，但是它们应该被只读处理：

{table}
*Property* | *Description*
baseDir | 项目的位置。
userHome | 用户的主目录。
grailsHome | 正在使用的Grails的安装位置（也许为null）。
grailsVersion | 被项目使用的Grails的版本。
grailsEnv | 当前的Grails环境。
config | 定义在 @BuildConfig.groovy@的配置定义内容。获取属性的方式和运行一致 @grailsSettings.config.foo.bar.hello@.
compileDependencies | 编译时项目依赖的文件实例列表。
testDependencies | 测试时项目依赖的文件实例列表。
runtimeDependencies | 运行时项目依赖的文件实例列表。
{table}

当然，如果你不能获得这些属性那么它们并没有多好。幸运的是这很容易实现：通过grailsSettings脚本变量可以得到一个BuildSettings实例用于你的脚本。你也可以在你的代码中通过使用grails.util.BuildSettingsHolder类来访问它，但是并不推荐这样做。

h3. 覆盖默认值

所有在第一个表中的属性都可以被一个系统属性或配置选项所覆盖——简单地使用“config option”名称。例如，要改变项目工作目录，你可以运行这个命令：
{code}
grails -Dgrails.project.work.dir=work compile
{code}
或者将这个选项添加到你的 @grails-app/conf/BuildConfig.groovy@文件中：
{code}
grails.project.work.dir = "work"
{code}
注意默认值带有许多它们依赖的属性值，因此像这样设置项目工作目录也将迁移编译好的类、测试类、资源和插件。

如果你同时使用系统属性和配置选项将发生什么？当然是系统属性被采用了，因为它优先于BuildConfig.groovy 文件，而后者优先于默认值。

BuildConfig.groovy 文件是 grails-app/conf/Config.groovy 的姐妹文件，——过去包含的选项仅仅影响构建，但是之后包含的就影响正在运行的应用程序了。这并不局限于第一个表中的选项：你会发现构建配置选项在文档中到处都是，比如其中一些就用来指定内嵌的servlet容器应该运行在哪个端口上或者决定哪些文件应该被打包到WAR文件中。

h3. 可用的构建设置

{table}
 Name | Description
 grails.server.port.http | 指定内嵌的servlet容器应该运行的端口（“run-app”和“run-war”命令使用）。整型。
 grails.server.port.https | 指定内嵌的servlet容器用于HTTPS的运行端口 ("run-app --https" and "run-war --https"). 整型.
 grails.config.base.webXml | 指定用于应用程序的自定义web.xml文件的路径（取代使用web.xml模板）。
 grails.compiler.dependencies | 将额外的依赖添加到编译器classpath的传统方式。设置它到一个包含“fileset()”入口的闭包。 这些入口将被一个AntBuilder处理，所以这些入口的语法是以Groovy的形式出现，对应着Ant构建文件的XML元素，例如： fileset(dir: "$basedir/lib", include: "**/*.class).
 grails.testing.patterns | 一个Ant路径格式的列表，允许你控制哪些文件可以被包含在测试中。这些格式不应该包括测试用例后缀，它们将在下一个属性中设置。
 grails.testing.nameSuffix | 默认的，测试类都假定有一个“Tests”的后缀。你可以设置这个选项来改变它为你想要的任何内容。例如：另一个公共后缀是“Test”。
 grails.project.war.file | 一个包含了生成的WAR文件的文件路径的字符串，除了它的全名意外（包括扩展名）。例如，“target/my-app.war”。
 grails.war.dependencies | 一个包含“fileset()”入口的闭包，它允许你完全控制什么内容可以被放入WAR文件的“WEB-INF/lib”目录中。
 grails.war.copyToWebApp | 一个包含“fileset()”入口的闭包，它允许你完全控制什么内容可以被放入WAR文件的根目录中。它覆盖了包含“web-app”目录下所有内容的那种默认习惯。
 grails.war.resources | 一个闭包，用临时目录的地址作为它的第一个参数。你可以使用任何Ant任务来做你想做的任何事。这通常用来在临时目录被打包成WAR之前从中删除文件。
 grails.project.web.xml | 生成Grails的web.xml的位置

h3. 重载代理缓存目录

Grails支持基于代理方式实现在应用开发环境且运行中代码变化的重载。这个就要求代理需要有效的处理缓存。默认缓存数据在 @\<USER_HOME_DIR\>\/.grails\/.slcache\/@。@GRAILS_AGENT_CACHE_DIR@环境参数将这个目录可以设置其他位置上。注意，这是一个系统环境变量，不是JVM系统参数或其它由 @BuildConfig@来定义的值。之所以是系统环境变量，是因为设置早于JVM启动，也同时在任何Grails代码执行之前。
