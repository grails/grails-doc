{hidden}
If all the other projects in your team or company are built using a standard build tool such as Ant or Maven, you become the black sheep of the family when you use the Grails command line to build your application. Fortunately, you can easily integrate the Grails build system into the main build tools in use today (well, the ones in use in Java projects at least).

h3. Ant Integration

When you create a Grails application with the [create-app|commandLine] command, Grails doesn't automatically create an Ant @build.xml@ file but you can generate one with the [integrate-with|commandLine] command:

bc.
grails integrate-with --ant

This creates a @build.xml@ file containing the following targets:

* @clean@ - Cleans the Grails application
* @compile@ - Compiles your application's source code
* @test@ - Runs the unit tests
* @run@ - Equivalent to "grails run-app"
* @war@ - Creates a WAR file
* @deploy@ - Empty by default, but can be used to implement automatic deployment

Each of these can be run by Ant, for example:

{code:java}
ant war
{code}

The build file is configured to use "Apache Ivy":http://ant.apache.org/ivy/ for dependency management, which means that it will automatically download all the requisite Grails JAR files and other dependencies on demand. You don't even have to install Grails locally to use it! That makes it particularly useful for continuous integration systems such as [CruiseControl|http://cruisecontrol.sourceforge.net/] or [Jenkins|http://jenkins-ci.org/].

It uses the Grails [Ant task|api:grails.ant.GrailsTask] to hook into the existing Grails build system. The task lets you run any Grails script that's available, not just the ones used by the generated build file. To use the task, you must first declare it:
{code}
<taskdef name="grailsTask"
         classname="grails.ant.GrailsTask"
         classpathref="grails.classpath"/>
{code}

This raises the question: what should be in "grails.classpath"? The task itself is in the "grails-bootstrap" JAR artifact, so that needs to be on the classpath at least. You should also include the "groovy-all" JAR. With the task defined, you just need to use it! The following table shows you what attributes are available:
{table}
 Attribute | Description | Required
 home | The location of the Grails installation directory to use for the build. | Yes, unless classpath is specified.
 classpathref | Classpath to load Grails from. Must include the "grails-bootstrap" artifact and should include "grails-scripts". | Yes, unless @home@ is set or you use a @classpath@ element.
 script | The name of the Grails script to run, e.g. "TestApp". | Yes.
 args | The arguments to pass to the script, e.g. "-unit -xml". | No. Defaults to "".
 environment | The Grails environment to run the script in. | No. Defaults to the script default.
 includeRuntimeClasspath | Advanced setting: adds the application's runtime classpath to the build classpath if true. | No. Defaults to @true@.
{table}

The task also supports the following nested elements, all of which are standard Ant path structures:

* @classpath@ - The build classpath (used to load Gant and the Grails scripts).
* @compileClasspath@ - Classpath used to compile the application's classes.
* @runtimeClasspath@ - Classpath used to run the application and package the WAR. Typically includes everything in @compileClasspath.
* @testClasspath@ - Classpath used to compile and run the tests. Typically includes everything in @runtimeClasspath@.

How you populate these paths is up to you. If you use the @home@ attribute and put your own dependencies in the @lib@ directory, then you don't even need to use any of them. For an example of their use, take a look at the generated Ant build file for new apps.

h3. Maven Integration

Grails provides integration with "Maven 2":http://maven.apache.org with a Maven plugin. 

h4. Preparation

In order to use the Maven plugin, all you need is Maven 2 installed and set up. This is because *you no longer need to install Grails separately to use it with Maven!*

{note}
The Maven 2 integration for Grails has been designed and tested for Maven 2.0.9 and above. It will not work with earlier versions.
{note}

{note}
The default mvn setup DOES NOT supply sufficient memory to run the Grails environment. We recommend that you add the following environment variable setting to prevent poor performance:

@export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=256"@
{note}

h4. Creating a Grails Maven Project

Using the @create-pom@ command you can generate a valid Maven @pom.xml@ file for any existing Grails project. The below presents an example:

{code}
$ grails create-app myapp
$ cd myapp
$ grails create-pom com.mycompany
{code}

The @create-pom@ command expects a group id as an argument. The name and the version are taken from the @application.properties@ of the application. The Maven plugin will keep the version in the @pom.xml@ in sync with the version in @application.properties@.

The following standard Maven commands are then possible:

* @compile@ - Compiles a Grails project
* @package@ - Builds a WAR file from the Grails project.
* @install@ - Builds a WAR file (or plugin zip/jar if a plugin) and installs it into your local Maven cache
* @test@ - Runs the tests of a Grails project
* @clean@ - Cleans the Grails project

Other standard Maven commands will likely work too.

You can also use some of the Grails commands that have been wrapped as Maven goals:

* @grails:create-controller@ - Calls the [create-controller|commandLine] command
* @grails:create-domain-class@ - Calls the [create-domain-class|commandLine] command
* @grails:create-integration-test@ - Calls the [create-integration-test|commandLine] command
* @grails:create-pom@ - Creates a new Maven POM for an existing Grails project
* @grails:create-script@ - Calls the [create-script|commandLine] command
* @grails:create-service@ - Calls the [create-service|commandLine] command
* @grails:create-taglib@ - Calls the [create-tag-lib|commandLine] command
* @grails:create-unit-test@ - Calls the [create-unit-test|commandLine] command
* @grails:exec@ - Executes an arbitrary Grails command line script
* @grails:generate-all@ - Calls the [generate-all|commandLine] command
* @grails:generate-controller@  - Calls the [generate-controller|commandLine] command
* @grails:generate-views@ - Calls the [generate-views|commandLine] command
* @grails:install-templates@ - Calls the [install-templates|commandLine] command
* @grails:list-plugins@ - Calls the [list-plugins|commandLine] command
* @grails:package@ - Calls the [package|commandLine] command
* @grails:run-app@ - Calls the [run-app|commandLine] command

For a complete, up to date list, run @mvn grails:help@

h4. Creating a Grails Maven Project using the Archetype

You can create a Maven Grails project without having Grails installed, simply run the following command:

{code}
mvn archetype:generate -DarchetypeGroupId=org.grails \\\
    -DarchetypeArtifactId=grails-maven-archetype \\\
    -DarchetypeVersion=2.1.0.RC1 \\\
    -DgroupId=example -DartifactId=my-app
{code}

Choose whichever grails version, group ID and artifact ID you want for your application, but everything else must be as written. This will create a new Maven project with a POM and a couple of other files. What you won't see is anything that looks like a Grails application. So, the next step is to create the project structure that you're used to.
But first, to set target JDK to Java 6, do that now. Open my-app/pom.xml and change

{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
{code}
to
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.6</source>
    <target>1.6</target>
  </configuration>
</plugin>
{code}

Then you're ready to create the project structure:

{code}
cd my-app
mvn initialize
{code}

h4. Defining Plugin Dependencies

All Grails plugins are published to a standard Maven repository located at [http://repo.grails.org/grails/plugins/]. When using the Maven plugin for Grails you must ensure that this repository is declared in your list of remote repositories:

{code:xml}
<repository>
    <id>grails-plugins</id>
    <name>grails-plugins</name>
    <url>http://repo.grails.org/grails/plugins</url>
</repository>
{code}

With this done you can declare plugin dependencies within your @pom.xml@ file:

{code:xml}
<dependency>
    <groupId>org.grails.plugins</groupId>
    <artifactId>database-migration</artifactId>
    <version>1.1</version>
    <scope>runtime</scope>
    <type>zip</type>
</dependency>
{code}

Note that the @type@ element must be set to @zip@.

h4. Forked Grails Execution

By default the Maven plugin will run Grails commands in-process, meaning that the Grails process occupies the same JVM as the Maven process. This can put strain on the Maven process for particularly large applications.

In this case it is recommended to use forked execution. Forked execution can be configured in the @configuration@ element of the plugin:

{code}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>${grails.version}</version>
    <configuration>
        <!-- Whether for Fork a JVM to run Grails commands -->
        <fork>true</fork>
    </configuration>
    <extensions>true</extensions>
</plugin>
{code}

With this configuration in place a separate JVM will be forked when running Grails commands. If you wish to debug the JVM that is forked you can add the @forkDebug@ element:

{code:xml}
    <!-- Whether for Fork a JVM to run Grails commands -->
    <fork>true</fork>
    <forkDebug>true</forkDebug>
{code}

If you need to customize the memory of the forked process the following elements are available:

* @forkMaxMemory@ - The maximum amount of heap (default 1024)
* @forkMinMemory@ - The minimum amount of heap (default 512)
* @forkPermGen@ - The amount of permgen (default 256)


h4. Multi Module Maven Builds

The Maven plugin can be used to power multi-module Grails builds. The easiest way to set this is up is with the @create-multi-project-build@ command:

{code}
$ grails create-app myapp
$ grails create-plugin plugin1
$ grails create-plugin plugin2
$ grails create-multi-project-build org.mycompany:parent:1.0
{code}

Running @mvn install@ will build all projects together. To enable the 'grails' command to read the POMs you can modify @BuildConfig.groovy@ to use the POM and resolve dependencies from your Maven local cache:

{code}
grails.project.dependency.resolution = {
    ...
    pom true
    repositories {
        ...
        mavenLocal()    
    }
}
{code}

By reading the @pom.xml@ file you can do an initial @mvn install@ from the parent project to build all plugins and install them into your local maven cache and then @cd@ into your project and use the regular @grails run-app@ command to run your application. All previously built plugins will be resolved from the local Maven cache.

h4. Adding Grails commands to phases

The standard POM created for you by Grails already attaches the appropriate core Grails commands to their corresponding build phases, so "compile" goes in the "compile" phase and "war" goes in the "package" phase. That doesn't help though when you want to attach a plugin's command to a particular phase. The classic example is functional tests. How do you make sure that your functional tests (using which ever plugin you have decided on) are run during the "integration-test" phase?

Fear not: all things are possible. In this case, you can associate the command to a phase using an extra "execution" block:

{code:xml}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>2.1.0.RC2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <goals>
            ...
            </goals>
        </execution>
        <!-- Add the "functional-tests" command to the "integration-test" phase -->
        <execution>
            <id>functional-tests</id>
            <phase>integration-test</phase>
            <goals>
                <goal>exec</goal>
            </goals>
            <configuration>
                <command>functional-tests</command>
            </configuration>
        </execution>
    </executions>
</plugin>
{code}

This also demonstrates the @grails:exec@ goal, which can be used to run any Grails command. Simply pass the name of the command as the @command@ system property, and optionally specify the arguments with the @args@ property:

{code}
mvn grails:exec -Dcommand=create-webtest -Dargs=Book
{code}

h4. Debugging a Grails Maven Project

Maven can be launched in debug mode using the "mvnDebug" command. To launch your Grails application in debug, simply run:

{code}
mvnDebug grails:run-app
{code}

The process will be suspended on startup and listening for a debugger on port 8000.

If you need more control of the debugger, this can be specified using the MAVEN_OPTS environment variable, and launch Maven with the default "mvn" command:

{code}
MAVEN_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
mvn grails:run-app
{code}

h4. Raising issues

If you come across any problems with the Maven integration, please raise a [JIRA issue|http://jira.grails.org/browse/MAVEN].

{hidden}
如果你的团队或公司的所有其他项目使用诸如Ant或Maven这样的标准构建工具，当你使用Grails命令行构建你的应用程序时，你就会给人不合群的感觉。幸运的是，你可以很容易地把Grails构建系统集成进如今使用的主要的构建工具（好吧，至少是Java项目使用的构建工具）。

h3. Ant集成

当使用使用[create-app|commandLine]目录创建Grails应用程序时，Grails不会自动创建一个Ant @build.xml@文件，但是你可以使用[integrate-with|commandLine]目录生成一个：

bc.
grails integrate-with \-\-ant

这个命令创建了一个包含下列目标的@build.xml@文件：

* @clean@ - 清理Grails应用程序
* @compile@ - 编译你应用程序的源代码
* @test@ - 运行单元测试
* @run@ - 等价于"grails run-app"
* @war@ - 创建WAR文件
* @deploy@ - 默认为空，但可以用于实现自动部署

每个目标都可以由Ant运行，例如：

{code:java}
ant war
{code}

这个构建文件被配置为使用"Apache Ivy":http://ant.apache.org/ivy/ 进行依赖管理，这意味着它会自动下载所有必须的Grails JAR文件和其他有需要的其他依赖。你甚至不必在本地安装Grails就可以使用它！这使它对于持续集成系统像[CruiseControl|http://cruisecontrol.sourceforge.net/]或[Jenkins|http://jenkins-ci.org/]来说特别有用。

它使用了Grails [Ant任务|api:grails.ant.GrailsTask]来接入现有的Grails构建系统。这个任务让你可以运行任何可用的Grails脚本，不仅仅是生成的构建文件中使用的Grails脚本。要使用这个任务，你必须首先声明它：
{code}
<taskdef name="grailsTask"
         classname="grails.ant.GrailsTask"
         classpathref="grails.classpath"/>
{code}

这引起了一个问题：什么应该出现在"grails.classpath"里面呢？这个任务自身位于"grails-bootstrap" JAR制品中，所以它至少出现在类路径上。你应该也包括"groovy-all" JAR。这个任务定义了之后，你只需使用它了！下面的表格向你展示了什么属性可以使用：
{table}
 属性 | 描述 | 必须
 home | 用于构建的Grails安装目录的位置 | 是，除非指定了classpath。
 classpathref | 加载Grials的类路径。必须包含"grails-bootstrap"制品并且应该包含"grails-scripts"。 | 是，除非@home@已设置或者你使用了@classpath@元素。
 script | 要运行的Grails脚本的名字，例如"TestApp"。| 是。
 args | 传递到脚本的参数，例如："-unit -xml"。 | 否。默认值是""。
 environment | 运行脚本的Grails环境。 | 否。默认是脚本中环境的默认值。
 includeRuntimeClasspath | 高级设置：如果为true，添加应用程序的运行时类路径到构建类路径。 | 否。默认值为@true@。
{table}

这个任务也支持如下的内嵌元素，所有的元素都是标准的Ant路径结构：

* @classpath@ - 构建类路径（用于加载Gant和Grails脚本）。
* @compileClasspath@ - 用于编译应用程序中类的类路径。
* @runtimeClasspath@ - 用于运行应用程序和打包WAR的类路径。通常包括@compileClasspath中的全部内容。
* @testClasspath@ - 用于编译和运行测试的类路径。通常包括@runtimeClasspath@中的全部内容。

怎样填充这些路径由你决定。如果你使用@home@属性，并且把你自己的依赖放在@lib@目录下，那么你甚至不需要使用它们中任何一个。有关它们用法的一个例子，可以查看为新应用程序生成的Ant构建文件。

h3. Maven集成

Grails使用一个Maven插件提供与"Maven 2":http://maven.apache.org 的集成。

h4. 准备

为了使用这个Maven插件，你所需要的是，已经安装并设置好了Maven 2。这是因为*你不再需要单独安装Grails来在Maven中使用它！*

{note}
Grails与Maven 2的集成已经针对Maven 2.0.9及以上版本进行设计并测试过。它不能与更早的版本一起工作。
{note}

{note}
默认的Maven设置没有提供充足的内存来运行Grails环境。我们推荐你添加下面的环境变量设置来防止性能问题:

@export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=256"@
{note}

h4. 创建一个Grails Maven项目

使用@create-pom@命令你可以为任何现有的Grails项目生成一个有效的@pom.xml@文件。下面展示了一个示例：

{code}
$ grails create-app myapp
$ cd myapp
$ grails create-pom com.mycompany
{code}

@create-pom@目录期望一个组织id作为参数。名字和版本从应用程序的@application.properties@文件获取。这个Maven插件将会把@pom.xml@中的版本与@application.properties@中的版本保持同步。

可以使用下列标准的Maven命令：

* @compile@ - 编译Grails项目
* @package@ - 从Grails项目构建WAR文件。
* @install@ - 构建WAR文件（或插件zip/jar文件，如果是插件的话）并将其安装到本地Maven缓存
* @test@ - 运行Grails项目的测试
* @clean@ - 清理Grails项目

其他的标准Maven命令同样也会工作。

你也可以使用那些封装为Maven目标的Grails命令：

* @grails:create-controller@ - 调用[create-controller|commandLine]命令
* @grails:create-domain-class@ - 调用[create-domain-class|commandLine]命令
* @grails:create-integration-test@ - 调用[create-integration-test|commandLine]命令
* @grails:create-pom@ - 为现有的Grails项目创建Maven POM
* @grails:create-script@ - 调用[create-script|commandLine]命令
* @grails:create-service@ - 调用[create-service|commandLine]命令
* @grails:create-taglib@ - 调用[create-tag-lib|commandLine]命令
* @grails:create-unit-test@ - 调用[create-unit-test|commandLine]命令
* @grails:exec@ - 执行任意的Grails命令行脚本
* @grails:generate-all@ - 调用[generate-all|commandLine]命令
* @grails:generate-controller@  - 调用[generate-controller|commandLine]命令
* @grails:generate-views@ - 调用[generate-views|commandLine]命令
* @grails:install-templates@ - 调用[install-templates|commandLine]命令
* @grails:list-plugins@ - 调用[list-plugins|commandLine]命令
* @grails:package@ - 调用[package|commandLine]命令
* @grails:run-app@ - 调用[run-app|commandLine]命令

要得到完整的最新的列表，运行@mvn grails:help@

h4. 使用Archetype创建Grails Maven项目

在没有安装Grails的情况下你可以创建一个Maven Grails项目，只需运行如下的命令：

{code}
mvn archetype:generate -DarchetypeGroupId=org.grails \\\
    -DarchetypeArtifactId=grails-maven-archetype \\\
    -DarchetypeVersion=2.1.0.RC1 \\\
    -DgroupId=example -DartifactId=my-app
{code}

要为你的应用程序选择合适的grails版本，组织ID和Artifact ID，其他的参数也必须被指定。这将创建一个新的带POM的Maven项目和一些其他的文件。你不会看到的是类似Grails应用程序的任何东西。所以，下一步是创建你已经习惯了的项目结构。
但是首先，设置目标JDK为Java 6，马上去完成。打开my-app/pom.xml并修改

{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
{code}
为
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.6</source>
    <target>1.6</target>
  </configuration>
</plugin>
{code}

然后你就准备好了，可以创建项目结构了：

{code}
cd my-app
mvn initialize
{code}

h4. 定义插件依赖

所有的Grails插件发布到一个位于[http://repo.grails.org/grails/plugins/]的标准Maven仓库。当使用这个针对Grails的Maven插件的时候，你必须确保这个仓库在你的远程仓库列表中被声明了：

{code:xml}
<repository>
    <id>grails-plugins</id>
    <name>grails-plugins</name>
    <url>http://repo.grails.org/grails/plugins</url>
</repository>
{code}

这个完成以后你可以在你的@pom.xml@文件里声明插件依赖：

{code:xml}
<dependency>
    <groupId>org.grails.plugins</groupId>
    <artifactId>database-migration</artifactId>
    <version>1.1</version>
    <scope>runtime</scope>
    <type>zip</type>
</dependency>
{code}

注意@type@元素必须设置为@zip@。

h4. 分叉的Grails执行

默认这个Maven插件将会在进程内运行Grails命令，意味着Grails进程会占据与Maven进程相同的JVM。对特别大型的应用程序这可能会对Maven进程产生负担。

在这种情况下推荐使用分叉执行。分叉执行可以在插件的@configuration@元素里配置：

{code}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>${grails.version}</version>
    <configuration>
        <!-- 是否分叉出一个JVM来运行Grails命令 -->
        <fork>true</fork>
    </configuration>
    <extensions>true</extensions>
</plugin>
{code}

这个配置就位后，当运行Grails命令时，会分叉出一个独立的JVM。如果你想调试分叉出的JVM，你可以添加@forkDebug@元素：

{code:xml}
    <!-- 是否分叉出一个JVM来运行Grails命令 -->
    <fork>true</fork>
    <forkDebug>true</forkDebug>
{code}

如果你需要定制分叉出的进程的内存大小，可以使用下面的元素：

* @forkMaxMemory@ - 堆的最大容量 (默认 1024)
* @forkMinMemory@ - 堆的最小容量 (默认 512)
* @forkPermGen@ - permgen的大小 (默认 256)

h4. 多模块Maven构建

这个Maven插件可以用于支持多模块的Grails构建。最容易的设置方法是使用@create-multi-project-build@命令：

{code}
$ grails create-app myapp
$ grails create-plugin plugin1
$ grails create-plugin plugin2
$ grails create-multi-project-build org.mycompany:parent:1.0
{code}

运行@mvn install@将会一起构建全部的项目。要使得'grails'命令读取POM文件你可以修改@BuildConfig.groovy@使之使用POM并从本地缓存中对依赖进行解析：

{code}
grails.project.dependency.resolution = {
    ...
    pom true
    repositories {
        ...
        mavenLocal()    
    }
}
{code}

通过读取@pom.xml@文件你可以从父项目进行一个初始的@mvn install@来构建所有的插件并把它们安装到你的本地Maven缓存，然后@cd@到你的项目目录并使用常规的@grails run-app@命令运行你的应用程序。所有以前构建的插件将会从本地Maven缓存中进行解析。

h4. 添加Grails命令到阶段中

由Grails为你创建的标准POM中已经将合适的核心Grails命令挂载到它们对应的构建阶段了，"compile"进入"compile"阶段，"war"进入"package"阶段。但当你想挂载一个插件的命令到一个特定的阶段的时候这不会有什么帮助。经典的例子是功能测试。你如何确保你的功能测试（使用你已经确定的任何插件都可以）在"integration-test"阶段中运行？

不要害怕：一切皆有可能。在这种情况下，你可以使用一个额外的"execution"代码块把命令关联到某个阶段。

{code:xml}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>2.1.0.RC2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <goals>
            ...
            </goals>
        </execution>
        <!-- 添加"functional-tests"命令到"integration-test"阶段 -->
        <execution>
            <id>functional-tests</id>
            <phase>integration-test</phase>
            <goals>
                <goal>exec</goal>
            </goals>
            <configuration>
                <command>functional-tests</command>
            </configuration>
        </execution>
    </executions>
</plugin>
{code}

这也演示了@grails:exec@目标，其可以用于运行任何Grails命令。仅需以@command@系统属性传递命令的名字，也可以选择使用@args@属性指定命令参数：

{code}
mvn grails:exec -Dcommand=create-webtest -Dargs=Book
{code}

h4. 调试Grails Maven项目

Mavne可以使用"mvnDebug"命令启动调试模式。要以调试模式启动Grails应用程序，只需运行：

{code}
mvnDebug grails:run-app
{code}

启动以后进程会被中断并在端口8000监听调试器的连接。

如果你需要对调试器的更多控制，可以使用MAVEN_OPTS环境变量设定，并使用默认的"mvn"命令启动Maven：

{code}
MAVEN_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
mvn grails:run-app
{code}

h4. 提交问题

如果你在使用Maven集成时遇到任何问题，请提交一个[JIRA issue|http://jira.grails.org/browse/MAVEN]问题报告。
