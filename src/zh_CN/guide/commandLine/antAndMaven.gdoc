如果你的团队或公司的所有其他项目都在使用像Ant或Maven这样的标准的构建工具进行构建的，而你使用Grails命令行来构建你的应用程序时你就可能成为团队或者公司这个大家庭的害群之马。幸运的是，今天你可以很容易的将Grails构建系统集成到当今主流的构建工具中（嗯，至少是在Java项目中使用的那种构建工具）。

h3. Ant 整合

当你通过 [create-app|commandLine] 命令来创建一个Grails应用程序时，Grails不会自动创建Apache Ant 工具使用的build.xml文件，但是你可以通过 [integrate-with|commandLine] 命令来生成一个：
bc.
grails integrate-with --ant

这个命令会创建一个 @build.xml@ 文件，这个文件包含了下列的任务：

* @clean@ - 清理Grails应用程序
* @compile@ - 编译你的应用程序的源码
* @test@ - 运行单元测试
* @run@ - 等同于“grails run-app”的功能
* @war@ - 创建一个WAR文件
* @deploy@ - 默认为空，但可以用它实现自动部署

这些任务都可以被Ant运行，例如：

{code:java}
ant war
{code}

为了实现依赖管理，构建文件已经被全面改进为使用 "Apache Ivy":http://ant.apache.org/ivy/ for dependency management，这意味着它可以自动下载所有需要的Grails JAR文件和其他以来的文件。你甚至不必在本地安装Grails就可以使用它了！这对于需要使用像  [CruiseControl|http://cruisecontrol.sourceforge.net/] 或 [Jenkins|http://jenkins-ci.org/]。这样的持续集成系统进行自动构建时特别有用。

这里使用了Grails的 [Ant task|api:grails.ant.GrailsTask]  来对现有的Grails构建系统进行钩子操作。这个任务允许你运行任何可用的Grails脚本，不只是由生成的构建文件所使用的那些。要使用某个任务，你必须先声明它：
{code}
<taskdef name="grailsTask"
         classname="grails.ant.GrailsTask"
         classpathref="grails.classpath"/>
{code}

这也引出了另外的问题：“grails.classpath”中应该是什么内容？这个任务本身是在“grails-bootstrap”这个JAR工件中的，因此至少grails-bootstrap-xxx.jar需要在classpath中。同时也应该包含“groovy-all”这个JAR。对于这个任务定义，你只需要使用它！下表列出了可用的属性：
{table}
 Attribute | Description | Required
 home | 构建时需要用到的Grails安装目录的位置。 |  是，除非classpath被指定否则必填。
 classpathref | 载入Grails的Classpath。必须包含“grails-bootstrap”工件并且应该包含“grails-scripts”。 | Yes, 除非home被设置或者你使用classpath元素否则必填。
 script | 要运行的Grails脚本的名称，例如：“TestApp”。 | 必填。
 args | 要加入脚本中的参数，例如：“-unit -xml”。 | 不是必填。默认为“”。
 environment | 运行脚本时的Grails环境。 | 不是必填。默认为脚本的default。
 includeRuntimeClasspath | 高级设置：如果设为true则将应用程序的运行时classpath添加到构建classpath中。 | 不是必填。默认为true。
{table}

这个任务也支持下列内嵌元素，这些全都是标准的Ant路径结构：

* @classpath@ - 构建classpath（用来载入Gant和Grails脚本）。
* @compileClasspath@ - 用来编译应用程序的类的Classpath。
* @runtimeClasspath@ - 用来运行应用程序并将程序打成WAR包的Classpath。通常包含了compileClasspath中的一切。
* @testClasspath@ - 用来编译和运行测试的Classpath。通常包含了runtimeClasspath中的一切。

要如何填写这些路径信息完全取决于你。如果你正在使用 home 属性并且把你自己的依赖内容放在了 lib 目录中，那么你不需要使用以上任何一个路径。如果想看看使用它们的例子，那么就查看为一个新应用而生成的Ant构建文件吧。

h3. Maven集成

Grails通过一个Maven插件提供了与 "Maven 2":http://maven.apache.org。

h4. 准备

为了使用这个新的插件，你只需要安装和设置Maven 2。你不再需要单独的安装Grails!

{note}
Grails集成Maven 2已经针对Maven 2.0.9及以上版本进行了设计和测试。它将无法工作在更早期的版本中。
{note}

{note}
默认的mvn设置没有配置充足的内存来运行grails环境。我们推荐你添加下面的环境变量防止系统表现不佳。

@export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=256"@
{note}

h4. 创建一个 Grails Maven 项目

可以为任何现存的Grails项目，使用 @create-pom@ 命令生成有效的Maven @pom.xml@。下面的例子：

{code}
$ grails create-app myapp
$ cd myapp
$ grails create-pom com.mycompany
{code}

@create-pom@命令需要一个group id作为参数。这个名字或版本取自与 @application.properties@ 。Maven插件将保持 @pom.xml@ 和 @application.properties@中的版本号保持一致。

下面含有Maven命令可能使用的命令参数：

* @compile@ - 编译Grails项目
* @package@ - 为Grails项目建立WAR文件
* @install@ - 按照插件方式建立WAR文件并放置到你本地的Maven缓存中
* @test@ - 运行及测试Grails项目
* @clean@ - 清理Grails项目

其它标准的Maven命令

你可以使用的一些和Grails相同的命令作为Maven目标要求：

* @grails:create-controller@ - [create-controller|commandLine] 命令
* @grails:create-domain-class@ - [create-domain-class|commandLine] 命令
* @grails:create-integration-test@ - [create-integration-test|commandLine] 命令
* @grails:create-pom@ - 为现有的Grails项目创建一个新的Maven POM文件
* @grails:create-script@ -  [create-script|commandLine] 命令
* @grails:create-service@ -  [create-service|commandLine] 命令
* @grails:create-taglib@ -  [create-tag-lib|commandLine] 命令
* @grails:create-unit-test@ -  [create-unit-test|commandLine] 命令
* @grails:exec@ - 执行一个任意的Grails命令行脚本
* @grails:generate-all@ -  [generate-all|commandLine] 命令
* @grails:generate-controller@  -  [generate-controller|commandLine] 命令
* @grails:generate-views@ -  [generate-views|commandLine] 命令
* @grails:install-templates@ -  [install-templates|commandLine] 命令
* @grails:list-plugins@ -  [list-plugins|commandLine] 命令
* @grails:package@ -  [package|commandLine] 命令
* @grails:run-app@ -  [run-app|commandLine] 命令

完成列表请输入 @mvn grails:help@

h4. 使用Archtype方式建立Grails Maven项目

你可以输入一下命令，来建立一个Maven Grails项目，此项可以无需Grails是否安装：

{code}
mvn archetype:generate -DarchetypeGroupId=org.grails \\\
    -DarchetypeArtifactId=grails-maven-archetype \\\
    -DarchetypeVersion=2.1.0.RC1 \\\
    -DgroupId=example -DartifactId=my-app
{code}

无论你想为你的应用选择哪个grails version，group ID和artifact ID，一切内容格式都必须像上面写的那样。这将创建一个新的Maven项目以及一个POM文件和一系列其他文件。这个项目看上去不像是一个Grails应用。因此，下一步就要创建一个你要使用的项目结构了。 但首先, 为了配置目标 JDK 为 Java 6， 打开 my-app/pom.xml 并且更新。

{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.5</source>
    <target>1.5</target>
  </configuration>
</plugin>
{code}
为
{code}
<plugin>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <source>1.6</source>
    <target>1.6</target>
  </configuration>
</plugin>
{code}

然后您就可以创建项目结构：

{code}
cd my-app
mvn initialize
{code}

h4. 定义插件依赖

所有的Grails插件被发布到标准的Maven仓库中 [http://repo.grails.org/grails/plugins/]。当使用这些插件时，你必须在你的远程仓库中定义这个地址。

{code:xml}
<repository>
    <id>grails-plugins</id>
    <name>grails-plugins</name>
    <url>http://repo.grails.org/grails/plugins</url>
</repository>
{code}

完成上面操作后，你可以在你的 @pom.xml@ 文件中定义插件依赖。

{code:xml}
<dependency>
    <groupId>org.grails.plugins</groupId>
    <artifactId>database-migration</artifactId>
    <version>1.1</version>
    <scope>runtime</scope>
    <type>zip</type>
</dependency>
{code}

@type@ 必需为 @zip@

h4. Forked Grails 执行

默认Maven插件将和Grails命令同步执行。这意味着，Grails和Maven使用相同的JVM。这样对较大的应用程序来说会加大Maven负担。

这种情况下，建议使用forked执行。Rorked执行配置通过以下方式：

{code}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>${grails.version}</version>
    <configuration>
        <!-- Whether for Fork a JVM to run Grails commands -->
        <fork>true</fork>
    </configuration>
    <extensions>true</extensions>
</plugin>
{code}

这样的话，Grails命令将以分开JVM执行。如果希望进行调试，你也可以加入 @forkDebug@ 节点：

{code:xml}
    <!-- Whether for Fork a JVM to run Grails commands -->
    <fork>true</fork>
    <forkDebug>true</forkDebug>
{code}

对于内存控制，以下值也是可以被使用的：

* @forkMaxMemory@ - The maximum amount of heap (default 1024)
* @forkMinMemory@ - The minimum amount of heap (default 512)
* @forkPermGen@ - The amount of permgen (default 256)


h4. 多个Maven模块的建立

Maven插件可以被用作多模块Grails的建立。你可以使用@create-multi-project-build@命令来实现：

{code}
$ grails create-app myapp
$ grails create-plugin plugin1
$ grails create-plugin plugin2
$ grails create-multi-project-build org.mycompany:parent:1.0
{code}

运行@mvn install@将所有项目组合在一起建立。可以修改@BuildConfig.groovy@文件，你可以从本地Maven使用POM及相关依赖缓存。

{code}
grails.project.dependency.resolution = {
    ...
    pom true
    repositories {
        ...
        mavenLocal()    
    }
}
{code}

By reading the @pom.xml@ file you can do an initial @mvn install@ from the parent project to build all plugins and install them into your local maven cache and then @cd@ into your project and use the regular @grails run-app@ command to run your application. All previously built plugins will be resolved from the local Maven cache.

h4. 添加Grails命令到 phase 中

标准的POM文件被创建是为了让Grails将合适的核心Grails命令附加到它们对应的构建语法上，因此“compile”对应“compile”语法，“war”对应“package”语法。当你想要将一个插件的命令附加到一个特定的phase上时，这可能没有什么帮助。典型的例子是功能测试。你如何确保你的功能测试（无论正在使用你决定的哪个插件）是使用“integration-test” phase来运行的?

恐怕不是：所有事情都是可能的。在这个例子中，你可以使用额外的“execution”块来将命令联合到一个 phase 上：

{code:xml}
<plugin>
    <groupId>org.grails</groupId>
    <artifactId>grails-maven-plugin</artifactId>
    <version>2.1.0.RC2</version>
    <extensions>true</extensions>
    <executions>
        <execution>
            <goals>
            ...
            </goals>
        </execution>
        <!-- Add the "functional-tests" command to the "integration-test" phase -->
        <execution>
            <id>functional-tests</id>
            <phase>integration-test</phase>
            <goals>
                <goal>exec</goal>
            </goals>
            <configuration>
                <command>functional-tests</command>
            </configuration>
        </execution>
    </executions>
</plugin>
{code}

这也展示了 grails:exec 目标，它可以用来运行任何Grails命令。简单的将命令的名字作为 command 系统特性，还可以通过 @args@ 特性来选择性地指定参数：

{code}
mvn grails:exec -Dcommand=create-webtest -Dargs=Book
{code}

h4. 调试一个 Grails Maven 工程

Maven可以使用“mvnDebug”命令在调试模式下启动。要启动调试你的Grails应用程序，只需运行：

{code}
mvnDebug grails:run-app
{code}

这一过程在启动的时候将被暂停和监听8000端口的调试器

如果您需要更多的控制调试器，这可以使用的MAVEN_OPTS环境变量指定，并用默认的“MVN”命令来启动Maven：

{code}
MAVEN_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"
mvn grails:run-app
{code}

h4. 提出问题

如果你遇到任何与Maven的集成的问题，请参阅 [JIRA issue|http://jira.grails.org/browse/MAVEN].
