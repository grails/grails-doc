A number of changes need to be considered when upgrading your application from Grails 2.2, some of them breaking. Here's a quick list with more detail on each item following after:
当Grails2.2向上升级时，需要有些改变。下面列表表明那些需要调整：

* 新的改善数据绑定 (no Spring property editors)
* 对于XSS攻击中诸多方面设置为默认转为HTML编码
* 新的依赖性解决引擎
* 必须在线接受Grails依赖
* Grails核心依赖重新整理
* Tomcat 和 Hibernate 插件本版本分离 (breaking!)
* 脚手架作为分离插件模式
* 默认使用 Spock 
* 默认在交互测试中依赖注入无法工作
* 为测试中加入执行
* 默认升级应用时 @run-app@ 无法工作
* @grails-debug@ 不再使用


h4. 新的数据绑定

新的数据绑定机制从根本上重写以符合Grails的实际需求。如果你继续希望使用Spring来作为数据绑定，那么你需要修改  @grails-app/conf/Config.groovy@ 文件中的 @grails.databinding.useSpringBinder@ 的值为 @true@ 。

h4. 编码中输出的安全改良 (XSS) Changes

Grails 2.3 包括新的机制来保护 XSS 攻击。它默认为新应用开启这个选项，但老版本应用需要手工来操作。
可以查阅 [Cross Site Scripting (XSS) prevention|guide:xssPrevention] 来看如何设置 XSS 保护。

h4. 依赖性解决方案

虽然依赖性Ivy还是予以支持，但默认 Grails 2.3 已经使用 Aether 和 Ivy 今后不再继续。
如果你希望使用 Aether 来替换你现有系统，可以通过 @grails-app/conf/BuildConfig.groovy@ ：
{code}
grails.project.dependency.resolver = "maven" // or ivy
{code}

如果你希望以认证方式连接到 maven 仓库，你需要修改这里：
{code}
mavenRepo("http://artifactory.mycompany.com/repo") {
    authentication(username: "myusername", password: "secret")
}
{code}

h4. 依赖元数据的改变

此外，用于Grails 2.3 POM和依赖的元数据已重新安排和清理，所以只有直接依赖的一个应用程序和所有其他指定的依赖关系是继承的。

着意味着升级后，Ehcache 是一个传递依赖Hibernate的插件, 而之前是直接依赖. 如Ehcache出现一个错误，它大部分是因为没有安装 Hibernate插件，以及直接定义了Ehcache关联：
(If get a compilation error related to Ehcache, it is most likely that you don't have the Hibernate plugin installed and need to directly declare the Ehcache dependency:)

{code}
compile "net.sf.ehcache:ehcache-core:2.4.6"
{code}

此外，当升级后元数据如何改变，去除一些不能运行的和做一些调整。可以运行 [dependency-report|commandLine] 查看新的依赖元数据以做出相应调整.

当升级时有这个错误信息：
{code}
| Configuring classpath
:: problems summary ::
:::: WARNINGS
    ::::::::::::::::::::::::::::::::::::::::::::::
    ::          UNRESOLVED DEPENDENCIES         ::
    ::::::::::::::::::::::::::::::::::::::::::::::
    :: org.springframework#spring-test;3.2.2.RELEASE: configuration not found in org.springframework#spring-test;3.2.2.RELEASE: 'compile'. It was required from org.grails#grails-plugin-testing;2.3.0.BUILD-SNAPSHOT compile
    ::::::::::::::::::::::::::::::::::::::::::::::
{code}

一个插件依赖于一个旧版的@spring-test@ (例如，[Mail plugin|http://grails.org/plugins/mail]). 修改这个问题可以运行 @grails dependency-report@ ，搜索插件是否传递依赖 @spring-test@ 并去除 (excludes) 它。
例如：

{code}
plugins {
  compile ':mail:1.0', {
    excludes 'spring-test'
  }
}
{code}

无论如何，更长远的办法是像我们建议的那样，直接弃用 Ivy，而使用 Aether方案来替换依赖解决方案：

{code}
grails.project.dependency.resolver="maven"
{code}

h4. Aether中不能作为离线模式 No initial offline mode with Aether

Aether的依赖解决方式，并不是通过本地文件获得。也就是说，Grails将不会把 GRAILS_HOME/lib 作为jar存放地的首选，而是从 Maven 库中取得相关 jar。
After they have been obtained from Maven central then Aether operates fine offline.

然而，你不能从你的本地Maven中获得所需的jar时，那么你只能将 Ivy 作为 BuildConfig。
If however you do not have the necessary jars in your local Maven repository, then the only way to get offline execution is to enable Ivy via BuildConfig (see above).


h4. Changes to Core plugin versioning schemes and the Upgrade command

Core plugins like @tomcat@ and @hibernate@ are no longer versioned the same as the Grails version, instead they are versioned according to the Tomcat and Hibernate version they target. If you are upgrading from Grails 2.2 you need to manually configure the correct Tomcat and Hibernate plugins in @BuildConfig@. The @upgrade@ command will not do this for you!

{code}
    plugins {
        // plugins for the build system only
        build ':tomcat:7.0.42'

        // plugins needed at runtime but not for compilation
        runtime ':hibernate:3.6.10.2'
    }
{code}

Note that the @upgrade@ command will be deprecated in 2.3 and replaced with a command named @use-current-grails-version@, which will make no attempts to automatically upgrade Grails applications.

h4. Scaffolding moved to a plugin and rewritten

If you have dynamically scaffolded controllers in your application then you will need to configure the 1.0 version of the [Scaffolding plugin|http://grails.org/plugin/scaffolding] in BuildConfig:

{code}
plugins {
  compile ':scaffolding:1.0.0'
}
{code}

By default for new applications the 2.0 version of the scaffolding plugin is used, which is not backwards compatible with 1.0.

h4. Spock included by default

You no longer need to add the Spock plugin to your projects. Simply create Spock specifications as before and they will be run as unit tests. In fact, don't install the Spock plugin, otherwise your specifications will run twice and potentially fail. This also means that the @spock@ test type no longer exists. Specifications and JUnit tests run as the same type now.

h4. Dependency Injection for Integration Tests

In order to support alternate JUnit4 test runners, Grails 2.3 no longer uses a special test runner to run tests and integration tests should no longer extend @GroovyTestCase@.

This change requires that any JUnit integration tests that require dependency injection now need to be annotated with:

{code}
\@TestMixin(IntegrationTestMixin)
{code}

For Spock integration tests, extending @IntegrationSpec@ also works.

h4. Forked Execution for Testing

Tests are now by default executed in a forked JVM (although this can be disabled). One implication of this is that tests will be slower to execute when using:

{code}
grails test-app
{code}

The reason for this is the need to load a separate JVM to execute tests. To mitigate this Grails interactive mode has been updated to load a background JVM that can be resumed. If you do:

{code}
$ grails // load interactive mode
$ grails -> test-app
$ grails -> test-app
{code}

Test execution will be noticably faster and is the recommended way to run tests in Grails. On older hardware that does not include multiple cores (to run the separate JVMs) it is recommended you disable forked execution for tests to achieve faster test execution times:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: false, // disable forked execution for test-app
   run: forkConfig, // configure settings for the run-app JVM
   ...
]
{code}

h4. Forked Execution and the Reloading Agent

In Grails 2.3 the reloading agent is no longer on the build system path unless you pass the @-reloading@ flag to the @grails@ command:

{code}
grails -reloading run-app
{code}

The reason for this is that the default in Grails 2.3 and above is to load Grails application in a forked JVM and enable the agent for the forked JVM. If you do not wish to use forked JVMs then you must ensure that you run Grails with the @-reloading@ flag. Alternatively, you can enable forking with the following configuration in @BuildConfig@:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: false, maxPerm: 256]
grails.project.fork = [
   test: forkConfig, // configure settings for the test-app JVM
   run: forkConfig, // configure settings for the run-app JVM
   war: forkConfig, // configure settings for the run-war JVM
   console: forkConfig // configure settings for the Swing console JVM
]
{code}

h4. Forked Execution and Remote Debugging

The @grails-debug@ command will no longer work with Grails for remote debugging sessions. The reason is the command enabled debugging for the build system JVM, but not the JVM used in forked execution. The solution to this is to use the @debug-fork@ command line argument:

{code}
grails --debug-fork run-app
{code}


Alternatively you can set the @debug@ setting to @true@ in @BuildConfig@ and use the regular @grails@ command to execute:

{code}
forkConfig = [maxMemory: 1024, minMemory: 64, debug: true, maxPerm: 256]
grails.project.fork = [
   run: forkConfig, // configure settings for the run-app JVM
   ...
{code}

h4. Forked Execution and Functional Test plugins

Some existing plugins (Cucumber plugin for example) do not work with 2.3.x forked execution because they expect the tests to be running in the same JVM as the application under tests. For example it is not possible to setup fixture / test data using GORM inside a functional test and have that data visible to the application under test since the application under test is in a separate JVM. The solution to this is to provide the necessary fixture data in the @BootStrap@ of the application (only for the test environment of course).
