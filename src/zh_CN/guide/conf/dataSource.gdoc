既然Grails是基于Java技术来设置数据源的，那么一些JDBC的知识是必不可少的。

如果你的数据库并非H2，那么你至少还需要一个JDBC驱动。以MySQL为例，你需要下载 "Connector/J":http://www.mysql.com/downloads/connector/j/

驱动通常打包成JAR。如果你需要的jar在Maven的存储库中存在，那么最好是通过Ivy来解析它们，比如下面是对MySQL驱动的依赖：

{code}
    dependencies {
        runtime 'mysql:mysql-connector-java:5.1.29'
    }
{code}

如果Ivy找不到，那么只需要将JAR放到你工程的lib目录即可。

一旦解决了JAR的问题，你需要来熟悉一下位于grails-app/conf/DataSource.groovy中的Grails数据源描述了。此文件包含如下所述的一些数据源的定义：

* @driverClassName@ - JDBC驱动的类名
* @username@ -  建立JDBC连接的用户名
* @password@ - 建立JDBC连接的密码
* @url@ -  JDBC数据库的URL
* @dbCreate@ - 是否根据领域类自动生成数据库-可以是'create-drop'、'create'、'update'或者'validate'
* @pooled@ - 是否使用连接池（缺省是true)
* @logSql@ - 是否将SQL输出到字符终端
* @formatSql@ - 格式化SQL
* @dialect@ - Hibernate用于跟数据库通讯的方言（dialect），可以是字符串或者类名。可以通过 [org.hibernate.dialect|http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/dialect/package-summary.html] 来查看所支撑的方言。
* @readOnly@ - 如果是true那么此数据源就是只读的，这是通过调用连接池的Connection的setReadOnly(true)来实现的。
* @transactional@ - If @false@ leaves the DataSource's transactionManager bean outside the chained BE1PC transaction manager implementation. This only applies to additional datasources.
* @persistenceInterceptor@ - 数据源连接到持久的拦截。 除非设置 @true@ ，否则不拦截。
* @properties@ - 设置数据源的额外属性。 [Tomcat Pool|http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html#Common_Attributes]  [documentation of the properties|https://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/tomcat/jdbc/pool/PoolConfiguration.html].
* @jmxExport@ - 如果设置 @false@, 将禁止注册 JMX MBeans 。默认是 @jmxEnabled = true@ 

一个MySQL的典型配置可能如下：

{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost:3306/my_database"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "username"
    password = "password"
    properties {
       jmxEnabled = true
       initialSize = 5
       maxActive = 50
       minIdle = 5
       maxIdle = 25
       maxWait = 10000
       maxAge = 10 * 60000
       timeBetweenEvictionRunsMillis = 5000
       minEvictableIdleTimeMillis = 60000
       validationQuery = "SELECT 1"
       validationQueryTimeout = 3
       validationInterval = 15000
       testOnBorrow = true
       testWhileIdle = true
       testOnReturn = false
       jdbcInterceptors = "ConnectionState;StatementCache(max=200)"
       defaultTransactionIsolation = java.sql.Connection.TRANSACTION_READ_COMMITTED
    }
}
{code}

{warning}
在配置数据源的时候，不要在配置名前加入任何类型或者def关键字，因为Groovy将其视为一个本地变量定义而将其忽略。比如：
{warning}

{code:java}
dataSource {
    boolean pooled = true // type declaration results in ignored local variable
    ...
}
{code}

一个使用额外属性配置的高级示例如下：

{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost:3306/my_database"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "username"
    password = "password"
    properties {
       // Documentation for Tomcat JDBC Pool
       // http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html#Common_Attributes
       // https://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/tomcat/jdbc/pool/PoolConfiguration.html
       jmxEnabled = true
       initialSize = 5
       maxActive = 50
       minIdle = 5
       maxIdle = 25
       maxWait = 10000
       maxAge = 10 * 60000
       timeBetweenEvictionRunsMillis = 5000
       minEvictableIdleTimeMillis = 60000
       validationQuery = "SELECT 1"
       validationQueryTimeout = 3
       validationInterval = 15000
       testOnBorrow = true
       testWhileIdle = true
       testOnReturn = false
       ignoreExceptionOnPreLoad = true
       // http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html#JDBC_interceptors
       jdbcInterceptors = "ConnectionState;StatementCache(max=200)"
       defaultTransactionIsolation = java.sql.Connection.TRANSACTION_READ_COMMITTED // safe default
       // controls for leaked connections 
       abandonWhenPercentageFull = 100 // settings are active only when pool is full
       removeAbandonedTimeout = 120
       removeAbandoned = true
       // use JMX console to change this setting at runtime
       logAbandoned = false // causes stacktrace recording overhead, use only for debugging
       // JDBC driver properties
       // Mysql as example
       dbProperties {
           // Mysql specific driver properties
           // http://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html
           // let Tomcat JDBC Pool handle reconnecting
           autoReconnect=false
           // truncation behaviour 
           jdbcCompliantTruncation=false
           // mysql 0-date conversion
           zeroDateTimeBehavior='convertToNull'
           // Tomcat JDBC Pool's StatementCache is used instead, so disable mysql driver's cache
           cachePrepStmts=false
           cacheCallableStmts=false
           // Tomcat JDBC Pool's StatementFinalizer keeps track
           dontTrackOpenResources=true
           // performance optimization: reduce number of SQLExceptions thrown in mysql driver code
           holdResultsOpenOverStatementClose=true
           // enable MySQL query cache - using server prep stmts will disable query caching
           useServerPrepStmts=false
           // metadata caching
           cacheServerConfiguration=true
           cacheResultSetMetadata=true
           metadataCacheSize=100
           // timeouts for TCP/IP
           connectTimeout=15000
           socketTimeout=120000
           // timer tuning (disable)
           maintainTimeStats=false
           enableQueryTimeouts=false
           // misc tuning
           noDatetimeStringSync=true
       }
    }
}
{code}

h4. 关于dbCreate

Hibernate能够根据你的领域类来自动创建数据库表。你可以通过dbCreate属性来进行一些控制，其可选值如下：

* *create* - 在启动时候，先删除已存在的，包括表、索引等，然后创建。
* *create-drop* -  同 create，不过在应用关闭的时候，也进行表删除。
* *update* - 创建不存在的表和索引，并且在不删除表和数据的情况下更新表结构。注意此种情况于很多限制，比如你不能很好地处理重命名字段（旧有地字段依然保留）
* *validate* - 不改变你数据库地任何信息，只是跟现有地数据库配置脚本进行比较，并且报告一个警告。其他什么都不做

如果你的数据库变化相对稳定或者你的应用部署于生产环境，推荐你将dbCreate完全移除。数据库的变更迁移可以通过SQL脚本或者迁移工具，比如 [Liquibase|http://www.liquibase.org/] （数据库迁移 "Database Migration":http://grails.org/plugin/database-migration 插件就是通过Liquibase来跟Grails和GORM紧密集成的)来完成。
