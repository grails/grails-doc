{hidden}
Since Grails is built on Java technology setting up a data source requires some knowledge of JDBC (the technology that doesn't stand for Java Database Connectivity).

If you use a database other than H2 you need a JDBC driver. For example for MySQL you would need "Connector/J":http://www.mysql.com/downloads/connector/j/

Drivers typically come in the form of a JAR archive. It's best to use Ivy to resolve the jar if it's available in a Maven repository, for example you could add a dependency for the MySQL driver like this:

{code}
grails.project.dependency.resolution = {
    inherits("global")
    log "warn"
    repositories {
        grailsPlugins()
        grailsHome()
        grailsCentral()
        mavenCentral()
    }
    dependencies {
        runtime 'mysql:mysql-connector-java:5.1.16'
    }
}
{code}

Note that the built-in @mavenCentral()@ repository is included here since that's a reliable location for this library.

If you can't use Ivy then just put the JAR in your project's @lib@ directory.

Once you have the JAR resolved you need to get familiar Grails' DataSource descriptor file located at @grails-app/conf/DataSource.groovy@. This file contains the dataSource definition which includes the following settings:

* @driverClassName@ - The class name of the JDBC driver
* @username@ - The username used to establish a JDBC connection
* @password@ - The password used to establish a JDBC connection
* @url@ - The JDBC URL of the database
* @dbCreate@ - Whether to auto-generate the database from the domain model - one of 'create-drop', 'create', 'update' or 'validate'
* @pooled@ - Whether to use a pool of connections (defaults to true)
* @logSql@ - Enable SQL logging to stdout
* @formatSql@ - Format logged SQL
* @dialect@ - A String or Class that represents the Hibernate dialect used to communicate with the database. See the [org.hibernate.dialect|http://docs.jboss.org/hibernate/stable/core/javadocs/org/hibernate/dialect/package-summary.html] package for available dialects.
* @readOnly@ - If @true@ makes the DataSource read-only, which results in the connection pool calling @setReadOnly(true)@ on each @Connection@
* @persistenceInterceptor@ - The default datasource is automatically wired up to the persistence interceptor, other datasources are not wired up automatically unless this is set to @true@
* @properties@ - Extra properties to set on the DataSource bean. See the [Commons DBCP BasicDataSource|http://commons.apache.org/dbcp/api-1.2.2/org/apache/commons/dbcp/BasicDataSource.html] documentation.

A typical configuration for MySQL may be something like:

{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost/yourDB"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "yourUser"
    password = "yourPassword"
}
{code}

{warning}
When configuring the DataSource do not include the type or the def keyword before any of the configuration settings as Groovy will treat these as local variable definitions and they will not be processed. For example the following is invalid:
{warning}

{code:java}
dataSource {
    boolean pooled = true // type declaration results in ignored local variable
    ...
}
{code}

Example of advanced configuration using extra properties:
{code:java}
dataSource {
    pooled = true
    dbCreate = "update"
    url = "jdbc:mysql://localhost/yourDB"
    driverClassName = "com.mysql.jdbc.Driver"
    dialect = org.hibernate.dialect.MySQL5InnoDBDialect
    username = "yourUser"
    password = "yourPassword"
    properties {
        maxActive = 50
        maxIdle = 25
        minIdle = 5
        initialSize = 5
        minEvictableIdleTimeMillis = 60000
        timeBetweenEvictionRunsMillis = 60000
        maxWait = 10000
        validationQuery = "/* ping */"
    }
}
{code}

h4. More on dbCreate

Hibernate can automatically create the database tables required for your domain model. You have some control over when and how it does this through the @dbCreate@ property, which can take these values:

* *create* - Drops the existing schemaCreates the schema on startup, dropping existing tables, indexes, etc. first.
* *create-drop* - Same as *create*, but also drops the tables when the application shuts down cleanly.
* *update* - Creates missing tables and indexes, and updates the current schema without dropping any tables or data. Note that this can't properly handle many schema changes like column renames (you're left with the old column containing the existing data).
* *validate* - Makes no changes to your database. Compares the configuration with the existing database schema and reports warnings.
* any other value - does nothing

You can also remove the @dbCreate@ setting completely, which is recommended once your schema is relatively stable and definitely when your application and database are deployed in production. Database changes are then managed through proper migrations, either with SQL scripts or a migration tool like [Liquibase|http://www.liquibase.org/] (the "Database Migration":http://grails.org/plugin/database-migration plugin uses Liquibase and is tightly integrated with Grails and GORM).
{hidden}
因为Grails基于Java技术构建，所以设置数据源需要一些JDBC（该技术不代表Java Database Connectivity）的知识。

如果你不使用H2数据库的话，你需要一个JDBC驱动程序。例如使用MySQL你将需要"Connector/J":http://www.mysql.com/downloads/connector/j/

驱动程序通常是JAR文件的形式。如果其存在于Maven仓库的话，最好使用Ivy进行驱动程序jar文件的解析，例如你可以为MySQL驱动程序添加如下的依赖：

{code}
grails.project.dependency.resolution = {
    inherits("global")
    log "warn"
    repositories {
        grailsPlugins()
        grailsHome()
        grailsCentral()
        mavenCentral()
    }
    dependencies {
        runtime 'mysql:mysql-connector-java:5.1.16'
    }
}
{code}

注意这里包含了内置的@mavenCentral()@仓库，因为这是该驱动程序的一个可靠位置。

如果你不能使用Ivy，那么只要把驱动程序的JAR文件放到项目的@lib@目录下即可。

一旦你有了驱动程序的JAR文件，你需要熟悉位于@grails-app/conf/DataSource.groovy@的数据源描述文件。该文件包含数据源的定义，含有如下的设置：

* @driverClassName@ - JDBC驱动程序的类名
* @username@ - 用于建立JDBC连接的用户名
* @password@ - 用于建立JDBC连接的密码
* @url@ - 数据库的JDBC URL
* @dbCreate@ - 是否从领域模型自动生成数据库 - 取值为'create-drop'、 'create'、 'update' 或 'validate'中的一个
* @pooled@ - 是否使用连接池（默认为true）
* @logSql@ - 启用SQL日志功能，记录到标准输出
* @formatSql@ - 格式化记录的SQL
* @dialect@ - 一个代表Hibernate方言的字符串或类，用于与数据库的通信。查看[org.hibernate.dialect|http://docs.jboss.org/hibernate/stable/core/javadocs/org/hibernate/dialect/package-summary.html]包了解可以使用的方言。
* @readOnly@ - 如果为@true@使数据源变成只读，这会让连接池在每个@Connection@上调用@setReadOnly(true)@
* @persistenceInterceptor@ - 默认数据源会自动设置持久拦截器，除非该属性设置为@true@，其他的数据源不会知道设置持久拦截器
* @properties@ - 设置DataSource组件的附加属性。请查看[Commons DBCP BasicDataSource|http://commons.apache.org/dbcp/api-1.2.2/org/apache/commons/dbcp/BasicDataSource.html]的文档
