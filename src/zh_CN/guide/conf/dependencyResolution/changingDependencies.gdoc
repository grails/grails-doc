{hidden}
h4. Configuration Changing dependencies

Typically, dependencies are constant. That is, for a given combination of @group@, @name@ and @version@ the jar (or plugin) that it refers to will never change. The Grails dependency management system uses this fact to cache dependencies in order to avoid having to download them from the source repository each time. Sometimes this is not desirable. For example, many developers use the convention of a _snapshot_ (i.e. a dependency with a version number ending in “-SNAPSHOT”) that can change from time to time while still retaining the same version number. We call this a "changing dependency".

Whenever you have a changing dependency, Grails will always check the remote repository for a new version. More specifically, when a changing dependency is encountered during dependency resolution its last modified timestamp in the local cache is compared against the last modified timestamp in the dependency repositories. If the version on the remote server is deemed to be newer than the version in the local cache, the new version will be downloaded and used.

{note}
Be sure to read the next section on "Dependency Resolution Caching" in addition to this one as it affects changing dependencies.
{note}

All dependencies (jars and plugins) with a version number ending in @-SNAPSHOT@ are *implicitly* considered to be changing by Grails. You can also explicitly specify that a dependency is changing by setting the changing flag in the dependency DSL (This is only required for Ivy, Aether does not support the 'changing' flag and treats dependencies that end with -SNAPSHOT as changing):

{code}
runtime ('org.my:lib:1.2.3') {
    changing = true
}
{code}

h4. Aether and SNAPSHOT dependencies

The semantics for handling snapshots when using Aether in Grails are the same as those when using the Maven build tool. The default snapshot check policy is to check once a day for a new version of the dependency. This means that if a new snapshot is published during the day to a remote repository you may not see that change unless you manually clear out your local snapshot.

If you wish to change the snapshot update policy you can do so by configuring an @updatePolicy@ for the repository where the snapshot was resolved from, for example:

{code}
repositories {
    mavenCentral {
        updatePolicy "interval:1"
    }
}
{code}

The above example configures an update policy that checks once a minute for changes. Note that that an @updatePolicy@ like the above will seriously impact performance of dependency resolution. The possibly configuration values for @updatePolicy@ are as follows:

* @never@ - Never check for new snapshots
* @always@ - Always check for new snapshots
* @daily@ - Check once a day for new snapshots (the default)
* @interval:x@ - Check once every x minutes for new snapshots

h4. Ivy and Changing dependencies

For those used to Maven snapshot handling, if you use Aether dependency management you can expect the same semantics as Maven. If you choose to use Ivy there is a caveat to the support for changing dependencies that you should be aware of. Ivy will stop looking for newer versions of a dependency once it finds a remote repository that has the dependency.

Consider the following setup:

{code}
grails.project.dependency.resolution = {
    repositories {
        mavenLocal()
        mavenRepo "http://my.org/repo"
    }
    dependencies {
        compile "myorg:mylib:1.0-SNAPSHOT"
    }
{code}

In this example we are using the local maven repository and a remote network maven repository. Assuming that the local OI dependency and the local Maven cache do not contain the dependency but the remote repository does, when we perform dependency resolution the following actions will occur:

* maven local repository is searched, dependency not found
* maven network repository is searched, dependency is downloaded to the cache and used

Note that the repositories are checked in the order they are defined in the @BuildConfig.groovy@ file. 

If we perform dependency resolution again without the dependency changing on the remote server, the following will happen:

* maven local repository is searched, dependency not found
* maven network repository is searched, dependency is found to be the same "age" as the version in the cache so will not be updated (i.e. downloaded)

Later on, a new version of @mylib 1.0-SNAPSHOT@ is published changing the version on the server. The next time we perform dependency resolution, the following will happen:

* maven local repository is searched, dependency not found
* maven network repository is searched, dependency is found to newer than version in the cache so will be updated (i.e. downloaded to the cache)

So far everything is working well.

Now we want to test some local changes to the @mylib@ library. To do this we build it locally and install it to the local Maven cache (how doesn't particularly matter). The next time we perform a dependency resolution, the following will occur:

* maven local repository is searched, dependency is found to newer than version in the cache so will be updated (i.e. downloaded to the cache)
* maven network repository is NOT searched as we've already found the dependency

This is what we wanted to occur. 

Later on, a new version of @mylib 1.0-SNAPSHOT@ is published changing the version on the server. The next time we perform dependency resolution, the following will happen:

* maven local repository is searched, dependency is found to be the same "age" as the version in the cache so will not be updated (i.e. downloaded)
* maven network repository is NOT searched as we've already found the dependency

This is likely to not be the desired outcome. We are now out of sync with the latest published snapshot and will continue to keep using the version from the local maven repository.

The rule to remember is this: when resolving a dependency, Ivy will stop searching as soon as it finds a repository that has the dependency at the specified version number. It will *not* continue searching all repositories trying to find a more recently modified instance.

To remedy this situation (i.e. build against the _newer_ version of @mylib 1.0-SNAPSHOT@ in the remote repository), you can either:

* Delete the version from the local maven repository, or
* Reorder the repositories in the @BuildConfig.groovy@ file

Where possible, prefer deleting the version from the local maven repository. In general, when you have finished building against a locally built SNAPSHOT always try to clear it from the local maven repository.

{note}
This changing dependency behaviour is an unmodifiable characteristic of the underlying dependency management system Apache Ivy. It is currently not possible to have Ivy search all repositories to look for newer versions (in terms of modification date) of the same dependency (i.e. the same combination of @group@, @name@ and @version@). If you want this behavior consider switching to Aether as the dependency manager.
{note}
{hidden}
h4. 配置不断变化的依赖

通常依赖是不变的。也就是说，对于一个给定的@group@、@name@和@version@的组合，它引用到的jar（或者插件）从不改变。Grails依赖管理系统使用这个事实来缓存依赖以避免每次必须从来源仓库中下载它们。有时这并不是想要的行为。例如，许多开发人员使用_snapshot_（也就是版本号结尾为“-SNAPSHOT”的依赖）约定，这种依赖会不时地发生变化，同时仍保持相同的版本号。我们称之为“不断变化的依赖”。

无论何时你有了不断变化的依赖，Grails将会总是检查远程仓库来获取一个新的版本。更具体地说，当一个不断变化的依赖在依赖解析遇到时，其本地缓存中该依赖的最后修改时间戳会与依赖仓库中的最后修改时间戳进行比较。如果远程服务器中的版本被认为比本地缓存中的更加新的话，新版本将会被下载和使用。

{note}
除本节外，一定要阅读下一节有关“依赖解析缓存”的内容，因为它会影响不断变化的依赖。
{note}

所有的版本号以@-SNAPSHOT@结尾的依赖（jar和插件）会隐式地被Grails认为是不断变化的。你可以显式地指定一个依赖是不断变化的，方法是设置依赖DSL中的changing标志（这只对Ivy是必须的，Aether不支持'chaning'标志并且把以-SNAPSHOT结尾的依赖处理成不断变化的依赖）：

{code}
runtime ('org.my:lib:1.2.3') {
    changing = true
}
{code}

h4. Aether和快照依赖

当在Grails里使用Aether时，处理快照的语义与使用Maven构建工具时的语义是相同的。默认的快照检查策略是每天检查一次依赖的新版本是否存在。这意味着，如果一个新的快照同一天在一个远程仓库中被发布的话，你可能不会看到该变化，除非你手动清除你的本地快照。

如果你希望更改快照更新的策略，你可以通过对快照进行解析的仓库配置@updatePolicy@来完成，例如：

{code}
repositories {
    mavenCentral {
        updatePolicy "interval:1"
    }
}
{code}

上面的例子配置了一个每分钟检查一次变化的更新策略。注意，类似上面的@updatePolicy@将会严重影响依赖解析的性能。对@updatePolicy@可能的配置值如下所示：

* @never@ - 从不检查新的快照是否存在
* @always@ - 总是检查新的快照是否存在
* @daily@ - 每天检查一次新的快照是否存在(默认值)
* @interval:x@ - 每x分钟检查一次新的快照是否存在

h4. Ivy和不断变化的依赖

对于习惯了Maven快照处理的开发人员，如果你使用Aether依赖管理的话，你可以期望与Maven相同的语义。如果你选择使用Ivy的话，对于不断变化的依赖的支持，有一个你需要了解的陷阱。一旦Ivy发现远程仓库中有依赖，它将停止查找该依赖的更新的版本。

考虑如下的设置：

{code}
grails.project.dependency.resolution = {
    repositories {
        mavenLocal()
        mavenRepo "http://my.org/repo"
    }
    dependencies {
        compile "myorg:mylib:1.0-SNAPSHOT"
    }
{code}

在这个例子中，我们使用本地Maven仓库和一个远程网络Maven仓库。假定本地OI依赖和本地Maven缓存中不包含该依赖，但是远程仓库包含它，当我们执行依赖解析时，会发生下面的动作：

* 搜索Maven本地仓库，未发现依赖
* 搜索网络仓库，依赖被下载到缓存并使用

注意，仓库以它们在@BuildConfig.groovy@文件中定义的顺序进行检查。

如果在远程服务器上该依赖没有变化的情况下我们再次执行依赖解析，将会发生如下的动作：

* 搜索Maven本地仓库，未发现依赖
* 搜索网络仓库，发现该依赖和缓存中的版本是相同的“年龄”，因此将不会被更新（即被下载）

后来，一个新版本的@mylib 1.0-SNAPSHOT@发布，改变了服务器上的版本。下次我们执行依赖解析时，将会发生如下的动作：

* 搜索Maven本地仓库，未发现依赖
* 搜索网络仓库，发现比缓存中更新版本的依赖，所以将会被更新（即被下载到缓存）

目前一切都工作得很好。

现在我们想测试@mylib@库的本地的改动。要完成这样的改动，我们在本地构建它并把它安装到本地Maven缓存（怎么做不是我们特别要关注的）。下次我们执行依赖解析时，将会发生如下的动作：

* 搜索Maven本地仓库，发现比缓存中的版本更新，所以将会被更新（即被下载到缓存）
* Maven网络仓库*不会*被搜索，因为我们已经发现了该依赖

这是我们想要发生的事情。

再后来，一个新版本的@mylib 1.0-SNAPSHOT@发布，改变了服务器上的版本。下次我们执行依赖解析时，将会发生如下的动作：

* 搜索Maven本地仓库，发现该依赖和缓存中版本是相同的“年龄”，因此不会被更新（即被下载）
* Maven网络仓库*不会*被搜索，因为我们已经发现了该依赖

这可能不是我们希望的结果。我们现在和最新发布的快照不再同步并且将会继续一直使用本地Maven仓库中的版本。

要记住的规则是：当解析依赖的时候，Ivy一发现一个仓库中有该依赖的一个特定版本，它将停止搜索。它将*不会*继续搜索全部的仓库试图发现一个离现在更近的修改过的依赖。

为了修正这种情形（也就是针对远程仓库中 _更新_ 版本的@mylib 1.0-SNAPSHOT@进行构建），你可以：

* 从本地Maven仓库中删除该版本，或者
* 修改 @BuildConfig.groovy@文件中仓库的顺序

可能的话，最好删除本地Maven仓库中的版本。一般来说，当你对一个本地构建的快照完成构建之后，总是试着从本地仓库中清除它。

{note}
不断变化的依赖的这种解析行为是底层Apache Ivy依赖管理系统的一个无法修改的特性。目前不可能让Ivy搜索所有的仓库来查找同一依赖（即相同的@group@、@name@和@version@的组合）的更新的版本（指修改日期）。
{note}
