h3. 基础

Grails利用其自身的配置机制来提供对 Log4j 日志系统的配置，因此你所需要做的只是将 @log4j@ 配置添加到 @grails-app/conf/Config.groovy@ 配置文件中。

那么log4j该配置什么样子呢？下边是一个基础的示例：

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet',  //  controllers
           'org.codehaus.groovy.grails.web.pages' //  GSP

    warn   'org.apache.catalina'
}
{code}

在上述示例中，那些名称以'org.codehaus.groovy.grails.web.servlet'或者'org.codehaus.groovy.grails.web.pages'开头的记录器，仅仅记录级别高于或等于'error'的信息；而名字以'org.apache.catalina'开始的记录器仅仅记录级别高于或等于'warn'的信息。要了解此中的意义，首先要知道日志级别是如何工作的。

h4. 日志级别

以下是按照优先级降序（由高到低）排列的标准日志级别：

# off
# fatal
# error
# warn
# info
# debug
# trace
# all

当你记录一条消息的时候，已经暗含地给此消息指定了级别，比如 @log.debug(msg)@ 方法，就是使用其'error'级别，同理 @log.debug(msg)@ 指定的是'debug'。上述从'off'到'all'的级别都有一个同名对应的日志方法。

日志系统使用记录器（介绍见下一节）配置的 message 级别来判断此消息是否应该输出，比如你有一个'org.example.domain'记录器，其配置如下：

{code:java}
warn 'org.example.domain'
{code}

那么级别是'warn'、'error'或者'fatal'的消息都将会输出，而其他级别的都将被忽略。

在我们继续记录器以前，我们需要对'off'和'all'的级别做一个小关注，它们都只能在配置中使用，你不能使用它们记录任何日志信息。因此如果你将级别配置为'off'，那么将不会有任何信息输出，而配置为'all'意味着你将看到所有的日志信息。

h4. 记录器 Loggers

记录器是日志系统的基础，但是依然有一些根源上的困惑，比如它们是什么？可否共享？以及如何配置它们？

一个记录器就是你要将信息记录进去的对象，因此 @log.debug(msg)@ 中的 @log@ 就是一个记录器实例（其类型是 [Log|http://commons.apache.org/logging/apidocs/org/apache/commons/logging/Log.html] ）. 这些记录器通过唯一的名字标识被缓存起来，因此如果两个不同的类使用同一个名字的记录器，那么这些记录器是同一个运行实例。

主要有两种方法来获取一个记录器：

# 使用注入到工件（比如领域类、控制器以及服务）中的log实例
# 直接使用 Commons Logging API.

如果你使用动态的 @log@ 属性，那么记录器的名字是'grails.app.<type>.<className>'，此处的type是工件的类型，比如'controller'或者'service'，而 @className@ 则是此工件的全名，假设你有如下的一个服务：

{code:java}
package org.example

class MyService {
    ...
}
{code}

那么上述记录器的名字是 'grails.app.services.org.example.MyService'。

对其他类来说，典型的方法是将记录器作为此类的一个静态常量字段，比如：

{code:java}
package org.other

import org.apache.commons.logging.LogFactory

class MyClass {
    private static final log = LogFactory.getLog(this)
    ...
}
{code}

上述代码中将创建一个名字为'org.other.MyClass'的记录器，注意：此处并没有'grails.app.'前缀，因为此类不是一个Grails工件。你还可以一个自定义的名字（比如"myLogger"）给 @getLog()@ 方法，但是这种用法并不常见，因为在日志系统中，名字中的点（'.'）是被特殊处理的。

h4. 配置记录器

你已在Grails中看到如何配置记录器了，比如：

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet'
}
{code}

此示例中，名字以'org.codehaus.groovy.grails.web.servlet'开始的记录器将忽略所有'warn'级别以下的消息。打住，在你的应用中真有此名字的记录器么？没有，那我们为什么要这样配置它呢？因为上述的规则将应用于任何以'org.codehaus.groovy.grails.servlet.'_开始_的记录器，比如类org.codehaus.groovy.grails.web.servlet.GrailsDispatcherServlet和org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequest。

换句话说，记录器是分层级的，这使得用包名来配置比其他方式容易很多。

在应用中，你最常记录的是控制器、服务以及其他工件的输出日志，这可以通过以前提到过的_grails.app.<artifactType>.<className>_来实现。需要注意的是类名必须是全名（包括包名），如下所示：

{code:java}
log4j = {
    // Set level for all application artifacts
    info "grails.app"

    // Set for a specific controller in the default package
    debug "grails.app.controllers.YourController"

    // Set for a specific domain class
    debug "grails.app.domain.org.example.Book"

    // Set for all taglibs
    info "grails.app.taglib"
}
{code}

在日志配置中，常用的标准工件名称如下：

* @conf@ - @grails-app/conf@ 下的任何类（过滤器除外），比如： @BootStrap.groovy@  (but excluding filters)
* @filters@ - 过滤器
* @taglib@ - 标签库
* @services@ - 服务类
* @controllers@ - 控制器
* @domain@ - 领域类

Grails本身也带有大量的日志信息，有时候这些信息对我们的开发很有裨益，尤其要诊断你应用的问题的时候。以下是一些你可能使用到的内部记录器：

* @org.codehaus.groovy.grails.commons@ -  核心工件信息，比如类加载等
* @org.codehaus.groovy.grails.web@ - Grails的web请求处理
* @org.codehaus.groovy.grails.web.mapping@ - 调试URL映射信息
* @org.codehaus.groovy.grails.plugins@ - 记录插件的活动情况
* @grails.spring@ - 在Grails和插件中定义的Spring的beans
* @org.springframework@ - Spring的活动情况
* @org.hibernate@ - Hibernate的活动情况

到目前为止，我们仅仅查看了记录器的显式配置，那么其他那些_没有_明确指定的将是什么情况呢？它们是被简单的忽略了么？请看下面的根记录器小节。

h4. 根记录器

所有的记录器对象配置都是从其根记录器继承而来的，因此一个记录器如果没有明确地配置，那么此记录器的任何消息规则都使用其根记录器的定义。或者说，根记录器提供日志系统的缺省配置。

Grails自动地将根记录器配置成只处理'error'级别地消息，并且将这些消息显示在命令行终端（stdout是从C语言中借鉴而来）中。你可以通过'root'来重新定义其行为，比如：

{code:java}
log4j = {
    root {
        info()
    }
    ...
}
{code}

上述示例将配置根记录器记录并且输出'info'级别的消息到缺省的字符输出器。你也可以配置根记录器将信息记录到一个或者多个输出器（在下小节中详细讨论）中。比如：

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

在上述示例中，根记录器将记录到两个输出器中：缺省的'stdout'输出器和自定义的'file'输出器。

对高级用户来说，还有另外一种配置根记录器的方式：传递给log4j闭包的参数root是org.apache.log4j.Logger实例，这让你可以直接操作logger：

{code:java}
log4j = { root ->
    root.level = org.apache.log4j.Level.DEBUG
    ...
}
{code}

更多 @Logger@ 实例的信息，请参考Log4j API文档。

如果你仅仅满足于将日志信息输出到字符终端，那么目前所涉及到的基本信息已经足够用的了。但是如果你还想输出到一个文件呢？以及想将特定记录器的信息输出到一个特定文件，而不是字符终端，又该如何做呢？这些疑问将在下一节的输出器中得到解答。

h3. 输出器 Appenders

记录器是很好的信息过滤机制，但是它们并不将信息进行任何物理的写操作，这些都是不同类型的输出器所做的事。比如缺省的一个就是将信息输出到字符终端，另外一个输出到一个文件等等，更有甚者，你还可以创建你自己的输出器！

下图展示了输出器在日志管道系统中的位置：

!logging.png!

如你所见，一个记录器可以挂载多个输出器。 在一个标准的Grails配置中，所有从根记录器而来的记录器都有一个名为'stdout'并唯一的字符终端输出器。你可以通过'appenders'代码块来增加更多的输出器，比如：

{code:java}
log4j = {
    appenders {
        rollingFile name: "myAppender",
                    maxFileSize: 1024,
                    file: "/tmp/logs/myApp.log"
    }
}
{code}

以下是缺省情况下，有效输出器的清单：

{table}
 *Name* | *Class* | *Description*
 jdbc | [JDBCAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/jdbc/JDBCAppender.html] | Logs to a JDBC connection.
 console | [ConsoleAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/ConsoleAppender.html] | Logs to the console.
 file | [FileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/FileAppender.html] | Logs to a single file.
 rollingFile | [RollingFileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/RollingFileAppender.html] | Logs to rolling files, for example a new file each day.
{table}

传递给输出器的每一个命名参数都将映射成实现了 [Appender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Appender.html] 接口的属性，因此上述的 @RollingFileAppender@ 的实例中， @name@, @maxFileSize@ 和 @file@ 都是其属性而已。

你可以添加任意你需要的输出器，只要确保它们的名字不重复就可以了。同一类型的输出器，你甚至还可以有多个实例，比如将日志内容输出到不同的文件中。

你如果倾向于手工创建输出器或者你需要的输出器不在上述的列表中，那么你只需简单的声明一个 @appender@ 代码即可，比如：

{code:java}
import org.apache.log4j.*

log4j = {
    appenders {
        appender new RollingFileAppender(
                name: "myAppender",
                maxFileSize: 1024,
                file: "/tmp/logs/myApp.log")
    }
}
{code}

此种方法通常用来配置 @JMSAppender@, @SocketAppender@, @SMTPAppender@ 等输出器。

一旦你声明了这些额外的输出器，那么你还需要将它们跟特定的记录器进行关联，这可以通过记录器的名称和记录级别来完成，比如：

{code:java}
error myAppender: "grails.app.controllers.BookController"
{code}

这样就可以保证记录器'grails.app.controllers.BookController'将消息发送到'myAppender'中以及配置在根记录器中的任何输出器，要在记录器中增加更多的输出器，只需要将他们加入到同级别的声明即可，比如：

{code:java}
error myAppender:      "grails.app.controllers.BookController",
      myFileAppender:  ["grails.app.controllers.BookController",
                        "grails.app.services.BookService"],
      rollingFile:     "grails.app.controllers.BookController"
{code}

上述示例同时也展示了在一个给定的输出器(@myFileAppender@ )中如何通过列表来配置多个记录器。

需要注意的是：一个记录器只能配置一个级别，如果你配置了如下的内容：

{code:java}
error myAppender:      "grails.app.controllers.BookController"
debug myFileAppender:  "grails.app.controllers.BookController"
fatal rollingFile:     "grails.app.controllers.BookController"
{code}

你将会发现'grails.app.controllers.BookController'记录器只记录'fatal'级别的消息，这是因为最后的级别设置将以前的覆盖掉了。你这样做的意图是想限制输出器的级别。

一个根'all'级别记录器关联的输出器将记录大量的日志信息，如果记录在文件中，也许还能忍受，但在字符终端完全是另外一回事。因此我们需要将字符终端的输出器只记录'info'及其级别以上内容：

{code:java}
log4j = {
    appenders {
        console name: "stdout", threshold: org.apache.log4j.Level.INFO
    }
}
{code}

此处的threshold参数用以判断那些消息需要截去。此参数对所有的输出器有效，但需要注意的是你必须使用Level实例－"info"字符串的便利用法不能工作。

h3. 自定义布局

多数情况下，Log4j DSL使用缺省的 [PatternLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html] ，除此之外，还有以下布局可以选择：

* @xml@ - 创建一个XML日志文件
* @html@ -  创建一个HTML日志文件
* @simple@ - 简单的文本文件
* @pattern@ -  Pattern布局的文件

你可以通过layout来给一个输出器自定义布局：

{code:java}
log4j = {
    appenders {
        console name: "customAppender",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

此配置对内置的"stdout"（输出到字符终端）也有效：

{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

h3. 特定环境的配置

既然日志是配置在Config.groovy中，你自然也就可以将其配置在环境相关的代码块中。不过这种方式有一个小问题：每次你配置log4j的时候，你必须提供完整的日志配置。或者换句话说，你不能选择性的覆盖部分配置－要么全覆盖要么一点也不覆盖。

为了避免此问题，日志DSL提供了自己的environment代码块配置，这样你就可以自由的配置了。

{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")

        environments {
            production {
                rollingFile name: "myAppender", maxFileSize: 1024,
                            file: "/tmp/logs/myApp.log"
            }
        }
    }

    root {
        //...
    }

    // other shared config
    info "grails.app.controller"

    environments {
        production {
            // Override previous setting for 'grails.app.controller'
            error "grails.app.controllers"
        }
    }
}
{code}

此处需要注意的是：你不能将environment代码块放在root定义的_内部_，但是你可以将其放在environment代码块中。

h3. 完整的栈跟踪

当一个异常发生时，可能有大量的来自Java和Groovy内部栈跟踪信息，这其实是很恼人的。Grails的过滤器将这些不相干的细节屏蔽了，并且将栈的跟踪信息限制非Grails/Groovy的类包范围。

当异常发生时，完整的跟踪信息总是被记录到StackTrace记录器中，此记录器缺省将内容输出到一个名为stacktrace.log的文件中。跟其他的记录器配合，你还可以改变其在配置中的行为，比如你可以将栈跟踪信息输出到字符终端：

{code:java}
error stdout: "StackTrace"
{code}

此动作不会阻止Grails创建stacktrace.log文件－它只是将栈跟踪重定向了而已。此外你还可以修改'stacktrace'输出器的位置信息，比如：

{code:java}
log4j = {
    appenders {
        rollingFile name: "stacktrace", maxFileSize: 1024,
                    file: "/var/tmp/logs/myApp-stacktrace.log"
    }
}
{code}

或者，你根本就不想输出'stacktrace'，只需要将其输出器配置为'null'即可：

{code:java}
log4j = {
    appenders {
        'null' name: "stacktrace"
    }
}
{code}

你如果想在字符终端看到所有的输出，你可以通过将'StackTrace'记录器和'stdout'输出器关联合并来实现。

最后，你如果想完全禁止栈跟踪的过滤，可以通过设置VM属性：grails.full.stacktrace为true来实现，比如：

{code:java}
grails -Dgrails.full.stacktrace=true run-app
{code}

h3. 屏蔽栈跟踪日志中的请求参数

当Grails记录栈跟踪信息的时候，有可能将当前请求参数的名称和值一并包含了。为了避免隐私信息被记录，可以通过设置grails.exceptionresolver.params.exclude来屏蔽那些有关隐私字段的名称，比如：

{code:java}
grails.exceptionresolver.params.exclude = ['password', 'creditCard']
{code}

请求参数也可以通过设置grails.exceptionresolver.logRequestParameters为false的方式来禁止掉。其运行于“开发”模式下，缺省值是true，除此之外的其他模式为false。

{code:java}
grails.exceptionresolver.logRequestParameters=false
{code}

h3. 记录器的继承

早期，我们提到过所有的记录器都是从跟记录器继承而来的，其继承的层次是通过'.'来分割的。这意味着一个记录器将一直使用其上一级的级别和输出器配置，当然了你覆盖除外。以如下配置为例：

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

此应用的所有记录器都是'debug'级别和'file'输出。拿如果我想给'stdout'使用特定类型的记录器，该如何做呢？修改记录器的'additivity'。

记录器使用'additivity'来检查是否要继承其父级配置，如果其值是false，就不再继承。缺省情况下，所有记录器都是true，即他们都继承自父级配置。那么我们该如何修改此配置呢？请看下例：

{code:java}
log4j = {
    appenders {
        ...
    }
    root {
        ...
    }

    info additivity: false
         stdout: \["grails.app.controllers.BookController",
                  "grails.app.services.BookService"\]
}
{code}

当你指定记录级别的时候，增加一个名为'additivity'的参数。需要注意的是，当使用此参数时，你必须要为其分配一个输出器。如下的配置将_不会_工作：

{code:java}
info additivity: false, \["grails.app.controllers.BookController",
                         "grails.app.services.BookService"\]
{code}

h3. 自定义栈跟踪的输出和过滤

总的来说，Groovy生成的那些特定栈跟踪信息是比较冗余的，并且对于诊断问题也造成不少的干扰。因此Grails使用org.codehaus.groovy.grails.exceptions.StackTraceFilterer接口来完成对不相关信息的过滤。要完成对特定信息的过滤，只需要再src/groovy或者src/java中实现上述接口，并且在Config.groovy注册一下即可：

{code}
grails.logging.stackTraceFiltererClass =
         'com.yourcompany.yourapp.MyStackTraceFilterer'
{code}

此外，Grails也可以让这些被过滤的栈信息更具有可读性，你只需要在src/groovy或者src/java下边实现org.codehaus.groovy.grails.exceptions.StackTracePrinter接口，并且在Config.groovy中注册即可：

{code}
grails.logging.stackTracePrinterClass =
         'com.yourcompany.yourapp.MyStackTracePrinter'
{code}

最后，为了能够在错误GSP页面中渲染出错信息，需要一个生成HTML的打印输出，其缺省的实现是org.codehaus.groovy.grails.web.errors.ErrorsViewStackTracePrinter，并且被注册为一个Spring服务。你也可以通过实现org.codehaus.groovy.grails.exceptions.StackTraceFilterer接口或者定义ErrorsViewStackTracePrinter的子类来实现属于自己的渲染器，并且将其在grails-app/conf/spring/resources.groovy中注册，如下：

{code}
import com.yourcompany.yourapp.MyErrorsViewStackTracePrinter

beans = {

    errorsViewStackTracePrinter(MyErrorsViewStackTracePrinter,
                                ref('grailsResourceLocator'))
}
{code}

h3. 替换日志框架

缺省情况下，Grails使用Log4J来完成日志操作。对大多数的人来说，这绝对绰绰有余，而且很多的用户也根本就不关心使用那个日志框架。但是，如果你不是那些大多数，并且确实很想使用另外一个替代品，比如 [JDK logging package|http://download.oracle.com/javase/6/docs/api/index.html?java/util/logging/package-summary.html] 自带的日志包或者[logback|http://logback.qos.ch/] 。这时候，你只需要简单地全局设置中排除一些依赖，并且添加你自己地依赖即可，比如：

{code}
grails.project.dependency.resolution = {
    inherits("global") {
        excludes "grails-plugin-logging", "log4j"
    }
    ...
    dependencies {
        runtime "ch.qos.logback:logback-core:0.9.29"
        ...
    }
    ...
}

{code}

如果你这么做了，那么你将在你的日志文件中记录未过滤的、标准的Java跟踪栈，此外你也不能使用先前介绍的DSL来进行日志配置，你只能使用你选择的日志框架所提供的配置机制。
