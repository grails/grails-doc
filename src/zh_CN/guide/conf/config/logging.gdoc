{hidden}
h3. The Basics

Grails uses its common configuration mechanism to provide the settings for the underlying "Log4j":http://logging.apache.org/log4j/1.2/index.html log system, so all you have to do is add a @log4j@ setting to the file @grails-app/conf/Config.groovy@.

So what does this @log4j@ setting look like? Here's a basic example:

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet',  //  controllers
           'org.codehaus.groovy.grails.web.pages' //  GSP

    warn   'org.apache.catalina'
}
{code}

This says that for loggers whose name starts with 'org.codehaus.groovy.grails.web.servlet' or 'org.codehaus.groovy.grails.web.pages', only messages logged at 'error' level and above will be shown. Loggers with names starting with 'org.apache.catalina' logger only show messages at the 'warn' level and above. What does that mean? First of all, you have to understand how levels work.

h4. Logging levels

There are several standard logging levels, which are listed here in order of descending priority:

# off
# fatal
# error
# warn
# info
# debug
# trace
# all

When you log a message, you implicitly give that message a level. For example, the method @log.error(msg)@ will log a message at the 'error' level. Likewise, @log.debug(msg)@ will log it at 'debug'. Each of the above levels apart from 'off' and 'all' have a corresponding log method of the same name.

The logging system uses that _message_ level combined with the configuration for the logger (see next section) to determine whether the message gets written out. For example, if you have an 'org.example.domain' logger configured like so:

{code:java}
warn 'org.example.domain'
{code}

then messages with a level of 'warn', 'error', or 'fatal' will be written out. Messages at other levels will be ignored.

Before we go on to loggers, a quick note about those 'off' and 'all' levels. These are special in that they can only be used in the configuration; you can't log messages at these levels. So if you configure a logger with a level of 'off', then no messages will be written out. A level of 'all' means that you will see all messages. Simple.

h4. Loggers

Loggers are fundamental to the logging system, but they are a source of some confusion. For a start, what are they? Are they shared? How do you configure them?

A logger is the object you log messages to, so in the call @log.debug(msg)@, @log@ is a logger instance (of type [Log|http://commons.apache.org/logging/apidocs/org/apache/commons/logging/Log.html]). These loggers are cached and uniquely identified by name, so if two separate classes use loggers with the same name, those loggers are actually the same instance.

There are two main ways to get hold of a logger:

# use the @log@ instance injected into artifacts such as domain classes, controllers and services;
# use the Commons Logging API directly.

If you use the dynamic @log@ property, then the name of the logger is 'grails.app.<type>.<className>', where @type@ is the type of the artifact, for example 'controllers' or 'services', and @className@ is the fully qualified name of the artifact. For example, if you have this service:

{code:java}
package org.example

class MyService {
    ...
}
{code}

then the name of the logger will be 'grails.app.services.org.example.MyService'.

For other classes, the typical approach is to store a logger based on the class name in a constant static field:

{code:java}
package org.other

import org.apache.commons.logging.LogFactory

class MyClass {
    private static final log = LogFactory.getLog(this)
    ...
}
{code}

This will create a logger with the name 'org.other.MyClass' - note the lack of a 'grails.app.' prefix since the class isn't an artifact. You can also pass a name to the @getLog()@ method, such as "myLogger", but this is less common because the logging system treats names with dots ('.') in a special way.

h4. Configuring loggers

You have already seen how to configure loggers in Grails:

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet'
}
{code}

This example configures loggers with names starting with 'org.codehaus.groovy.grails.web.servlet' to ignore any messages sent to them at a level of 'warn' or lower. But is there a logger with this name in the application? No. So why have a configuration for it? Because the above rule applies to any logger whose name _begins with_ 'org.codehaus.groovy.grails.web.servlet.' as well. For example, the rule applies to both the @org.codehaus.groovy.grails.web.servlet.GrailsDispatcherServlet@ class and the @org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequest@ one.

In other words, loggers are hierarchical. This makes configuring them by package much simpler than it would otherwise be.

The most common things that you will want to capture log output from are your controllers, services, and other artifacts. Use the convention mentioned earlier to do that: _grails.app.<artifactType>.<className>_. In particular the class name must be fully qualifed, i.e. with the package if there is one:

{code:java}
log4j = {
    // Set level for all application artifacts
    info "grails.app"

    // Set for a specific controller in the default package
    debug "grails.app.controllers.YourController"

    // Set for a specific domain class
    debug "grails.app.domain.org.example.Book"

    // Set for all taglibs
    info "grails.app.taglib"
}
{code}

The standard artifact names used in the logging configuration are:

* @conf@ - For anything under @grails-app/conf@ such as @BootStrap.groovy@ (but excluding filters)
* @filters@ - For filters
* @taglib@ - For tag libraries
* @services@ - For service classes
* @controllers@ - For controllers
* @domain@ - For domain entities

Grails itself generates plenty of logging information and it can sometimes be helpful to see that. Here are some useful loggers from Grails internals that you can use, especially when tracking down problems with your application:

* @org.codehaus.groovy.grails.commons@ - Core artifact information such as class loading etc.
* @org.codehaus.groovy.grails.web@ - Grails web request processing
* @org.codehaus.groovy.grails.web.mapping@ - URL mapping debugging
* @org.codehaus.groovy.grails.plugins@ - Log plugin activity
* @grails.spring@ - See what Spring beans Grails and plugins are defining
* @org.springframework@ - See what Spring is doing
* @org.hibernate@ - See what Hibernate is doing

So far, we've only looked at explicit configuration of loggers. But what about all those loggers that _don't_ have an explicit configuration? Are they simply ignored? The answer lies with the root logger.

h4. The Root Logger

All logger objects inherit their configuration from the root logger, so if no explicit configuration is provided for a given logger, then any messages that go to that logger are subject to the rules defined for the root logger. In other words, the root logger provides the default configuration for the logging system.

Grails automatically configures the root logger to only handle messages at 'error' level and above, and all the messages are directed to the console (stdout for those with a C background). You can customise this behaviour by specifying a 'root' section in your logging configuration like so:

{code:java}
log4j = {
    root {
        info()
    }
    ...
}
{code}

The above example configures the root logger to log messages at 'info' level and above to the default console appender. You can also configure the root logger to log to one or more named appenders (which we'll talk more about shortly):

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

In the above example, the root logger will log to two appenders - the default 'stdout' (console) appender and a custom 'file' appender.

For power users there is an alternative syntax for configuring the root logger: the root @org.apache.log4j.Logger@ instance is passed as an argument to the log4j closure. This lets you work with the logger directly:

{code:java}
log4j = { root ->
    root.level = org.apache.log4j.Level.DEBUG
    ...
}
{code}

For more information on what you can do with this @Logger@ instance, refer to the Log4j API documentation.

Those are the basics of logging pretty well covered and they are sufficient if you're happy to only send log messages to the console. But what if you want to send them to a file? How do you make sure that messages from a particular logger go to a file but not the console? These questions and more will be answered as we look into appenders.

h3. Appenders

Loggers are a useful mechanism for filtering messages, but they don't physically write the messages anywhere. That's the job of the appender, of which there are various types. For example, there is the default one that writes messages to the console, another that writes them to a file, and several others. You can even create your own appender implementations\!

This diagram shows how they fit into the logging pipeline:

!logging.png!

As you can see, a single logger may have several appenders attached to it. In a standard Grails configuration, the console appender named 'stdout' is attached to all loggers through the default root logger configuration. But that's the only one. Adding more appenders can be done within an 'appenders' block:

{code:java}
log4j = {
    appenders {
        rollingFile name: "myAppender",
                    maxFileSize: 1024,
                    file: "/tmp/logs/myApp.log"
    }
}
{code}

The following appenders are available by default:

{table}
 *Name* | *Class* | *Description*
 jdbc | [JDBCAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/jdbc/JDBCAppender.html] | Logs to a JDBC connection.
 console | [ConsoleAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/ConsoleAppender.html] | Logs to the console.
 file | [FileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/FileAppender.html] | Logs to a single file.
 rollingFile | [RollingFileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/RollingFileAppender.html] | Logs to rolling files, for example a new file each day.
{table}

Each named argument passed to an appender maps to a property of the underlying [Appender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Appender.html] implementation. So the previous example sets the @name@, @maxFileSize@ and @file@ properties of the @RollingFileAppender@ instance.

You can have as many appenders as you like - just make sure that they all have unique names. You can even have multiple instances of the same appender type, for example several file appenders that log to different files.

If you prefer to create the appender programmatically or if you want to use an appender implementation that's not available in the above syntax, simply declare an @appender@ entry with an instance of the appender you want:

{code:java}
import org.apache.log4j.*

log4j = {
    appenders {
        appender new RollingFileAppender(
                name: "myAppender",
                maxFileSize: 1024,
                file: "/tmp/logs/myApp.log")
    }
}
{code}

This approach can be used to configure @JMSAppender@, @SocketAppender@, @SMTPAppender@, and more.

Once you have declared your extra appenders, you can attach them to specific loggers by passing the name as a key to one of the log level methods from the previous section:

{code:java}
error myAppender: "grails.app.controllers.BookController"
{code}

This will ensure that the 'grails.app.controllers.BookController' logger sends log messages to 'myAppender' as well as any appenders configured for the root logger. To add more than one appender to the logger, then add them to the same level declaration:

{code:java}
error myAppender:      "grails.app.controllers.BookController",
      myFileAppender:  ["grails.app.controllers.BookController",
                        "grails.app.services.BookService"],
      rollingFile:     "grails.app.controllers.BookController"
{code}

The above example also shows how you can configure more than one logger at a time for a given appender (@myFileAppender@) by using a list.

Be aware that you can only configure a single level for a logger, so if you tried this code:

{code:java}
error myAppender:      "grails.app.controllers.BookController"
debug myFileAppender:  "grails.app.controllers.BookController"
fatal rollingFile:     "grails.app.controllers.BookController"
{code}

you'd find that only 'fatal' level messages get logged for 'grails.app.controllers.BookController'. That's because the last level declared for a given logger wins. What you probably want to do is limit what level of messages an appender writes.

An appender that is attached to a logger configured with the 'all' level will generate a lot of logging information. That may be fine in a file, but it makes working at the console difficult. So we configure the console appender to only write out messages at 'info' level or above:

{code:java}
log4j = {
    appenders {
        console name: "stdout", threshold: org.apache.log4j.Level.INFO
    }
}
{code}

The key here is the @threshold@ argument which determines the cut-off for log messages. This argument is available for all appenders, but do note that you currently have to specify a @Level@ instance - a string such as "info" will not work.

h3. Custom Layouts

By default the Log4j DSL assumes that you want to use a [PatternLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html]. However, there are other layouts available including:

* @xml@ - Create an XML log file
* @html@ - Creates an HTML log file
* @simple@ - A simple textual log
* @pattern@ - A Pattern layout

You can specify custom patterns to an appender using the @layout@ setting:

{code:java}
log4j = {
    appenders {
        console name: "customAppender",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

This also works for the built-in appender "stdout", which logs to the console:
{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

h3. Environment-specific configuration

Since the logging configuration is inside @Config.groovy@, you can put it inside an environment-specific block. However, there is a problem with this approach: you have to provide the full logging configuration each time you define the @log4j@ setting. In other words, you cannot selectively override parts of the configuration - it's all or nothing.

To get around this, the logging DSL provides its own environment blocks that you can put anywhere in the configuration:

{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")

        environments {
            production {
                rollingFile name: "myAppender", maxFileSize: 1024,
                            file: "/tmp/logs/myApp.log"
            }
        }
    }

    root {
        //...
    }

    // other shared config
    info "grails.app.controller"

    environments {
        production {
            // Override previous setting for 'grails.app.controller'
            error "grails.app.controllers"
        }
    }
}
{code}

The one place you can't put an environment block is _inside_ the @root@ definition, but you can put the @root@ definition inside an environment block.

h3. Full stacktraces

When exceptions occur, there can be an awful lot of noise in the stacktrace from Java and Groovy internals. Grails filters these typically irrelevant details and restricts traces to non-core Grails/Groovy class packages.

When this happens, the full trace is always logged to the @StackTrace@ logger, which by default writes its output to a file called @stacktrace.log@. As with other loggers though, you can change its behaviour in the configuration. For example if you prefer full stack traces to go to the console, add this entry:

{code:java}
error stdout: "StackTrace"
{code}

This won't stop Grails from attempting to create the stacktrace.log file - it just redirects where stack traces are written to. An alternative approach is to change the location of the 'stacktrace' appender's file:

{code:java}
log4j = {
    appenders {
        rollingFile name: "stacktrace", maxFileSize: 1024,
                    file: "/var/tmp/logs/myApp-stacktrace.log"
    }
}
{code}

or, if you don't want to the 'stacktrace' appender at all, configure it as a 'null' appender:

{code:java}
log4j = {
    appenders {
        'null' name: "stacktrace"
    }
}
{code}

You can of course combine this with attaching the 'stdout' appender to the 'StackTrace' logger if you want all the output in the console.

Finally, you can completely disable stacktrace filtering by setting the @grails.full.stacktrace@ VM property to @true@:

{code:java}
grails -Dgrails.full.stacktrace=true run-app
{code}

h3. Masking Request Parameters From Stacktrace Logs

When Grails logs a stacktrace, the log message may include the names and values of all of the request parameters for the current request.  To mask out the values of secure request parameters, specify the parameter names in the @grails.exceptionresolver.params.exclude@ config property:

{code:java}
grails.exceptionresolver.params.exclude = ['password', 'creditCard']
{code}

Request parameter logging may be turned off altogether by setting the @grails.exceptionresolver.logRequestParameters@ config property to @false@.  The default value is @true@ when the application is running in DEVELOPMENT mode and @false@ for all other modes.

{code:java}
grails.exceptionresolver.logRequestParameters=false
{code}

h3. Logger inheritance

Earlier, we mentioned that all loggers inherit from the root logger and that loggers are hierarchical based on '.'-separated terms. What this means is that unless you override a parent setting, a logger retains the level and the appenders configured for that parent. So with this configuration:

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

all loggers in the application will have a level of 'debug' and will log to both the 'stdout' and 'file' appenders. What if you only want to log to 'stdout' for a particular logger? Change the 'additivity' for a logger in that case.

Additivity simply determines whether a logger inherits the configuration from its parent. If additivity is false, then its not inherited. The default for all loggers is true, i.e. they inherit the configuration. So how do you change this setting? Here's an example:

{code:java}
log4j = {
    appenders {
        ...
    }
    root {
        ...
    }

    info additivity: false
         stdout: \["grails.app.controllers.BookController",
                  "grails.app.services.BookService"\]
}
{code}

So when you specify a log level, add an 'additivity' named argument. Note that you when you specify the additivity, you must configure the loggers for a named appender. The following syntax will _not_ work:

{code:java}
info additivity: false, \["grails.app.controllers.BookController",
                         "grails.app.services.BookService"\]
{code}

h3. Customizing stack trace printing and filtering

Stacktraces in general and those generated when using Groovy in particular are quite verbose and contain many stack frames that aren't interesting when diagnosing problems. So Grails uses a implementation of the @org.codehaus.groovy.grails.exceptions.StackTraceFilterer@ interface to filter out irrelevant stack frames. To customize the approach used for filtering, implement that interface in a class in src/groovy or src/java and register it in @Config.groovy@:

{code}
grails.logging.stackTraceFiltererClass =
         'com.yourcompany.yourapp.MyStackTraceFilterer'
{code}

In addition, Grails customizes the display of the filtered stacktrace to make the information more readable. To customize this, implement the @org.codehaus.groovy.grails.exceptions.StackTracePrinter@ interface in a class in src/groovy or src/java and register it in @Config.groovy@:

{code}
grails.logging.stackTracePrinterClass =
         'com.yourcompany.yourapp.MyStackTracePrinter'
{code}

Finally, to render error information in the error GSP, an HTML-generating printer implementation is needed. The default implementation is @org.codehaus.groovy.grails.web.errors.ErrorsViewStackTracePrinter@ and it's registered as a Spring bean. To use your own implementation, either implement the @org.codehaus.groovy.grails.exceptions.StackTraceFilterer@ directly or subclass @ErrorsViewStackTracePrinter@ and register it in @grails-app/conf/spring/resources.groovy@ as:

{code}
import com.yourcompany.yourapp.MyErrorsViewStackTracePrinter

beans = {

    errorsViewStackTracePrinter(MyErrorsViewStackTracePrinter,
                                ref('grailsResourceLocator'))
}
{code}

h3. Alternative logging libraries

By default, Grails uses Log4J to do its logging. For most people this is absolutely fine, and many users don't even care what logging library is used. But if you're not one of those and want to use an alternative, such as the [JDK logging package|http://download.oracle.com/javase/6/docs/api/index.html?java/util/logging/package-summary.html] or [logback|http://logback.qos.ch/], you can do so by simply excluding a couple of dependencies from the global set and adding your own:

{code}
grails.project.dependency.resolution = {
    inherits("global") {
        excludes "grails-plugin-logging", "log4j"
    }
    ...
    dependencies {
        runtime "ch.qos.logback:logback-core:0.9.29"
        ...
    }
    ...
}

{code}

If you do this, you will get unfiltered, standard Java stacktraces in your log files and you won't be able to use the logging configuration DSL that's just been described. Instead, you will have to use the standard configuration mechanism for the library you choose.

{hidden}
h3. 基础

Grails利用其公共的配置机制提供对 "Log4j":http://logging.apache.org/log4j/1.2/index.html 日志系统的配置，因此你所需要做的只是添加@log4j@配置到@grails-app/conf/Config.groovy@配置文件中。

那么@log4j@配置看起来像什么呢？下边是一个基础的示例：

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet',  //  控制器
           'org.codehaus.groovy.grails.web.pages' //  GSP

    warn   'org.apache.catalina'
}
{code}

以'org.codehaus.groovy.grails.web.servlet'或者'org.codehaus.groovy.grails.web.pages'开头的记录器，只有级别等于或高于'error'的信息才会显示；而名字以'org.apache.catalina'开始的记录器仅显示级别等于或高于'warn'的信息。它们的含义是什么？首先，你必须了解日志级别是如何工作的。

h4. 日志级别

有几个标准的日志级别，以下按照优先级降序的方式将他们列出：

# off
# fatal
# error
# warn
# info
# debug
# trace
# all

当你记录一条消息的时候，已经隐式地给此消息指定了级别.比如@log.error(msg)@方法，就是以'error'级别记录一条信息。同样地，@log.debug(msg)@将会以'debug'级别记录。上述从'off'到'all'的级别都有一个同名的对应的日志方法。

日志系统使用记录器（介绍见下一节）配置的 _信息_ 级别来确定此信息是否应该输出，例如，如果你有一个'org.example.domain'记录器配置如下：

{code:java}
warn 'org.example.domain'
{code}

那么级别是'warn'、'error'或者'fatal'的信息将会输出，而其他级别的都将被忽略。

在我们继续记录器的讨论以前，我们需要对'off'和'all'的级别做一个快速注解，它们都只能在配置中使用；你不能在这些级别记录日志信息。因此如果你将记录器的级别配置为'off'，那么将不会有任何信息输出。配置为级别'all'意味着你将看到所有的日志信息。简单吧。

h4. 记录器（Loggers）

记录器是日志系统的基础，但是他们也是一些困惑的根源之一。比如它们是什么？可否共享？以及如何配置它们？

一个记录器是你将信息记录进去的对象，因此在@log.debug(msg)@调用中的@log@就是一个记录器实例（其类型是[Log|http://commons.apache.org/logging/apidocs/org/apache/commons/logging/Log.html]）。这些记录器被缓存并可以通过唯一的名字标识，因此如果两个不同的类使用相同名字的记录器，那么这些记录器是实际上是同一个实例。

主要有两种方法来获取一个记录器：

# 使用注入到比如领域类、控制器以及服务层工件中的@log@实例；
# 直接使用Commons Logging API。

如果你使用动态@log@属性，那么记录器的名字是'grails.app.<type>.<className>'，@type@是工件的类型，例如'controller'或者'service'，而@className@是此工件的完全限定的类名。例如，如果你有如下的一个服务层组件：

{code:java}
package org.example

class MyService {
    ...
}
{code}

那么上述记录器的名字是'grails.app.services.org.example.MyService'。

对其他类型，通常的方法是将基于类名的记录器作为一个静态常量字段：

{code:java}
package org.other

import org.apache.commons.logging.LogFactory

class MyClass {
    private static final log = LogFactory.getLog(this)
    ...
}
{code}

这会创建一个名字为'org.other.MyClass'的记录器，注意此处没有'grails.app.'前缀，因为此类不是一个Grails工件。你还可以传递自定义的名字（比如"myLogger"）到@getLog()@方法，但是这种用法并不常见，因为在日志系统中，名字中的点（'.'）是被特殊处理的。


h4. 配置记录器

你已经看到在Grails中如何配置记录器了：

{code:java}
log4j = {
    error  'org.codehaus.groovy.grails.web.servlet'
}
{code}

这个例子配置了名字以'org.codehaus.groovy.grails.web.servlet'开始的记录器将忽略所有'warn'级别及以下的信息。但是在应用程序中有这个名字的记录器吗？没有。那我们为什么要对其进行配置？因为上述的规则也应用于任何以'org.codehaus.groovy.grails.servlet.'_开始_的记录器。举例说明，这个规则可应用于类@org.codehaus.groovy.grails.web.servlet.GrailsDispatcherServlet@和@org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequest@。

换句话说，记录器是层次结构的，这使得用包名来配置比其他方式容易很多。

你想要配置日志输出的最常见的组件是控制器、服务层组件以及其他工件。这可以通过以前提到过的_grails.app.<artifactType>.<className>_来实现。特别说明类名必须是完全限定的，也就是如果位于包中的话要用包名限定：

{code:java}
log4j = {
    // 设置所有应用程序中的工件的日志级别
    info "grails.app"

    // 为缺省包中一个特定的控制器进行设置
    debug "grails.app.controllers.YourController"

    // 对一个特定的领域类进行设置
    debug "grails.app.domain.org.example.Book"

    // 对所有的标签库进行设置
    info "grails.app.taglib"
}
{code}

日志配置中常用的标准工件名称如下：

* @conf@ - @grails-app/conf@下的任何类型例如@BootStrap.groovy@（不包括过滤器）
* @filters@ - 过滤器
* @taglib@ - 标签库
* @services@ - 服务层类
* @controllers@ - 控制器
* @domain@ - 领域实体类

Grails自身生成大量的日志信息，有时候看到这些信息对我们很有帮助。以下是一些你可以使用的来自Grails内部的有用的记录器，尤其是要定位你的应用程序问题的时候：

* @org.codehaus.groovy.grails.commons@ - 核心工件信息，比如类加载等
* @org.codehaus.groovy.grails.web@ - Grails的web请求处理
* @org.codehaus.groovy.grails.web.mapping@ - 调试URL映射
* @org.codehaus.groovy.grails.plugins@ - 记录插件的活动情况
* @grails.spring@ - 在Grails和插件中正在定义的Spring组件
* @org.springframework@ - Spring的处理
* @org.hibernate@ - Hibernate的处理

到目前为止，我们仅仅查看了记录器的显式配置。那么其他那些_没有_明确配置的记录器是什么情况？它们是被简单地忽略了吗？请答案在于根记录器的配置。


h4. 根记录器

所有的记录器对象都是从其根记录器继承它们的配置，因此一个记录器如果没有提供显示地配置，那么记录到该记录器的此记录器的任何信息将会受为根记录器定义的规则约束。或者说，根记录器提供日志系统的缺省配置。

Grails自动地将根记录器配置成只处理'error'级别及以上的信息，并且将这些信息定向至控制台（对那些有C语言背景的人而言是stdout）中。你可以通过'root'配置区域像下面这样定制其行为：

{code:java}
log4j = {
    root {
        info()
    }
    ...
}
{code}

上述示例将配置根记录器记录'info'级别级以上的信息到默认的控制台输出器。你也可以配置根记录器将信息记录到一个或者多个带名字的输出器中（我们将立即进行更多的说明）：

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

在上述示例中，根记录器将记录到两个输出器中：缺省的'stdout'输出器（控制台）和自定义的'file'输出器。

对高级用户来说，还有另外一种配置根记录器的替代语法：传递给log4j闭包的参数root是@org.apache.log4j.Logger@实例。这让你可以直接对记录器进行设置：

{code:java}
log4j = { root ->
    root.level = org.apache.log4j.Level.DEBUG
    ...
}
{code}

有关@Logger@实例如何设置的更多信息，请参考Log4j API文档。

上述内容已经很好地涉及了日志的基础知识，而且如果你满足于将日志信息只输出到控制台的话这就够用了。但是如果你想输出到一个文件呢？你怎样确保特定的记录器的信息输出到一个文件而不是控制台呢？这些问题及更多的问题当我们接触到输出器时会得到解答。

h3. 输出器

记录器是一个有用的信息过滤机制，但是它们并不将信息在任何地方进行实际地写入。这是输出器的工作，有各种各样的输出器类型。例如缺省的输出器是将信息写出到控制台，另外一个输出器将信息写出一个文件，还有几个其他的输出器。你甚至可以创建你自己的输出器实现！

下图展示了日志管道中各种部件是怎样整合的：

!logging.png!

如你所见，一个记录器可以挂载多个输出器。 在一个标准的Grails配置中，名为'stdout'的控制台输出器通过默认的根记录器配置挂载到所有的记录器。但那也是唯一的一个输出器。你可以在'appenders'代码块中添加更多的输出器：

{code:java}
log4j = {
    appenders {
        rollingFile name: "myAppender",
                    maxFileSize: 1024,
                    file: "/tmp/logs/myApp.log"
    }
}
{code}

下列的输出器默认可用：

{table}
 *名称* | *类名* | *描述*
 jdbc | [JDBCAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/jdbc/JDBCAppender.html] | 记录到JDBC连接。
 console | [ConsoleAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/ConsoleAppender.html] | 记录到控制台。
 file | [FileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/FileAppender.html] | 记录到单个文件。
 rollingFile | [RollingFileAppender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/RollingFileAppender.html] | 记录到滚动文件，例如每天一个新文件。
{table}

传递给输出器的每一个命名参数都将映射到底层[Appender|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Appender.html]实现的属性。因此上述的例子中设置了@RollingFileAppender@的@name@、@maxFileSize@和@file@等属性。

你可以根据需要有多个输出器，只要确保它们都有一个唯一的的名字。你甚至还可以有相同类型的输出器的多个实例，例如输出到不同文件中的多个文件输出器。

你如果倾向于编程的方式创建输出器或者你想使用不在上述语法中的输出器实现，只需简单地使用你想要的输出器实例声明一个@appender@即可：

{code:java}
import org.apache.log4j.*

log4j = {
    appenders {
        appender new RollingFileAppender(
                name: "myAppender",
                maxFileSize: 1024,
                file: "/tmp/logs/myApp.log")
    }
}
{code}

这种方法可以用于配置@JMSAppender@、@SocketAppender@和@SMTPAppender@及更多的输出器。

一旦你声明了这些额外的输出器，你可以通过传递输出器的名字作为键名到前面章节介绍的某个日志级别方法挂载他们到特定的记录器：

{code:java}
error myAppender: "grails.app.controllers.BookController"
{code}

这样就可以确保记录器'grails.app.controllers.BookController'将日志信息发送到'myAppender'中以及配置在根记录器中的任何输出器，要在记录器中增加更多的输出器，那么将他们添加至相同的日志级别方法的声明即可，比如：

{code:java}
error myAppender:      "grails.app.controllers.BookController",
      myFileAppender:  ["grails.app.controllers.BookController",
                        "grails.app.services.BookService"],
      rollingFile:     "grails.app.controllers.BookController"
{code}

上述示例同时也展示了在一个给定的输出器(@myFileAppender@)中如何通过列表来一次性地配置多个记录器。

需要注意的是一个记录器只能配置一个日志级别，如果你配置了如下的内容：

{code:java}
error myAppender:      "grails.app.controllers.BookController"
debug myFileAppender:  "grails.app.controllers.BookController"
fatal rollingFile:     "grails.app.controllers.BookController"
{code}

你将会发现'grails.app.controllers.BookController'记录器只记录'fatal'级别的消息。这是因为对给定的记录器的最后声明的级别设置生效了。你可能想完成的配置是限制写出的信息的级别。

一个配置成'all'级别的记录器关联的输出器将产生大量的日志信息。如果记录在文件中还没有问题，但在控制台下很难工作。因此我们将控制台输出器只记录'info'级别及以上的信息：

{code:java}
log4j = {
    appenders {
        console name: "stdout", threshold: org.apache.log4j.Level.INFO
    }
}
{code}

此处的关键是@threshold@参数，其决定那些日志信息需要截去。此参数对所有的输出器可用，但需要注意你必须指定@Level@实例———类似"info"的字符串不能工作。

h3. 自定义布局

默认Log4j DSL假定你想使用[PatternLayout|http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html]。但是，其他的布局也可以使用：

* @xml@ - 创建一个XML日志文件
* @html@ - 创建一个HTML日志文件
* @simple@ - 简单的文本文件
* @pattern@ - Pattern布局的文件

你可以使用@layout@为输出器指定自定义布局：

{code:java}
log4j = {
    appenders {
        console name: "customAppender",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

这种方法也适用于内置的"stdout"输出器，其记录日志到控制台：
{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")
    }
}
{code}

h3. 环境特定的配置

既然日志配置位于@Config.groovy@文件中，你可以将其置于特定环境的代码块中。不过这种方式有一个问题：每次你定义@log4j@设置的时候，你必须提供完整的日志配置。换句话说，你不能选择性地覆盖部分配置———要么全覆盖要么一点也不覆盖。

为了解决这个问题，日志DSL提供了自己的环境相关的代码块，你可以在将其放在配置的任何地方：

{code:java}
log4j = {
    appenders {
        console name: "stdout",
                layout: pattern(conversionPattern: "%c{2} %m%n")

        environments {
            production {
                rollingFile name: "myAppender", maxFileSize: 1024,
                            file: "/tmp/logs/myApp.log"
            }
        }
    }

    root {
        //...
    }

    // 其他的共享配置
    info "grails.app.controller"

    environments {
        production {
            // 覆盖前面对'grails.app.controller'的配置
            error "grails.app.controller"
        }
    }
}
{code}

你不能将环境代码块放置的一个地方是@root@定义的_内部_，但是你可以将@root@定义放在环境代码块中。

h3. 完整的栈跟踪

当异常发生时，可能有大量的来自Java和Groovy内部的令人生畏的栈跟踪信息。Grails过滤掉这些通常不相关的细节并且限制追踪信息仅来自非Grails/Grovvy核心类的包中。

当异常发生时，完整的跟踪信息总是被记录到@StackTrace@记录器中，该记录器缺省将跟踪信息输出到一个名为@stacktrace.log@的文件中。和其他的记录器类似，你可以在配置中改变它的行为，例如，如果你希望将栈跟踪信息输出到控制台，添加如下内容：

{code:java}
error stdout: "StackTrace"
{code}

这不会阻止Grails创建stacktrace.log文件———它只是重定向栈跟踪写入的位置。另一种替代的方法是改变'stacktrace'输出器的文件位置：

{code:java}
log4j = {
    appenders {
        rollingFile name: "stacktrace", maxFileSize: 1024,
                    file: "/var/tmp/logs/myApp-stacktrace.log"
    }
}
{code}

或者，如果你根本不需要'stacktrace'输出器，将其配置为'null'输出器即可：

{code:java}
log4j = {
    appenders {
        'null' name: "stacktrace"
    }
}
{code}

如果你想要所有的输出都出现在控制台中，你当然可以将此与关联至'stdout'输出器的'StackTrace'记录器进行组合

最后，如果你想完全禁止对栈跟踪的过滤，可以设置@grails.full.stacktrace@ VM属性的值为@true@：

{code:java}
grails -Dgrails.full.stacktrace=true run-app
{code}

h3. 在栈跟踪日志中屏蔽请求参数

当Grails记录栈跟踪时，日志信息可能包含当前请求的所有请求参数的名字和值。为了对安全的请求参数的值进行屏蔽，在@grails.exceptionresolver.params.exclude@配置属性中指定这些参数的名字：

{code:java}
grails.exceptionresolver.params.exclude = ['password', 'creditCard']
{code}

通过设置@grails.exceptionresolver.logRequestParameters@配置属性的值为@false@可以完全关闭请求参数的日志功能。当应用程序在开发模式下运行时该属性的默认值是@true@，在所有其他模式下为@false@。

{code:java}
grails.exceptionresolver.logRequestParameters=false
{code}

h3. 记录器继承

稍早的时候，我们提到过所有的记录器从根记录器继承配置并且记录器是基于'.'分隔的层次结构。这意味着除非你覆盖父记录器的设置，记录器保持父记录器所配置的日志级别和输出器。因此使用如下配置：

{code:java}
log4j = {
    appenders {
        file name:'file', file:'/var/logs/mylog.log'
    }
    root {
        debug 'stdout', 'file'
    }
}
{code}

应用程序中所有的记录器将设置日志级别为'debug'并且记录日志至'stdout'和'file'两个输出器。如果对一个特定的记录器你只想输出至'stdout'呢？在这种情况下要修改记录器的'additivity'设置。

可加性仅仅决定一个记录器是否从父记录器继承配置。如果可加性为false，那么它的配置不从父记录器继承。所有记录器的可加性设置默认为true，也就是他们继承配置。那么你如何改变这个设置呢？下面是一个示例：

{code}
log4j = {
    appenders {
        ...
    }
    root {
        ...
    }

    info additivity: false
         stdout: \["grails.app.controllers.BookController",
                  "grails.app.services.BookService"\]
}
{code}

因此当你指定日志级别的时候，你添加'additivity'命名参数。注意每当你指定可加性时，你必须对一个带名字的输出器配置记录器的可加性。下面的语法_不能_工作：

{code:java}
info additivity: false, \["grails.app.controllers.BookController",
                         "grails.app.services.BookService"\]
{code}

h3. 定制栈跟踪的输出和过滤

一般的栈跟踪，特别是使用Groovy产生的栈跟踪非常详细并且包含许多栈帧，它们在诊断问题时不是很有趣。所以Grails使用一个@org.codehaus.groovy.grails.exceptions.StackTraceFilterer@接口的实现来过滤掉不相关的栈帧。为了定制用于过滤的方法，在一个位于src/groovy和src/java下的类中实现这个接口并在@Config.groovy@中对其注册：

{code}
grails.logging.stackTraceFiltererClass =
         'com.yourcompany.yourapp.MyStackTraceFilterer'
{code}

此外，Grails可以定制已过滤的栈跟踪的显示使得信息更加可读。要进行定制，在位于src/groovy和src/java下的类中实现@org.codehaus.groovy.grails.exceptions.StackTracePrinter@接口并在@Config.groovy@中对其注册：

{code}
grails.logging.stackTracePrinterClass =
         'com.yourcompany.yourapp.MyStackTracePrinter'
{code}

最后，为了在错误GSP页面中显示错误信息，Grails提供了生成HTML的打印器实现。默认的实现是 @org.codehaus.groovy.grails.web.errors.ErrorsViewStackTracePrinter@并且注册为一个Spring组件。为了使用你自己的实现，直接实现@org.codehaus.groovy.grails.exceptions.StackTraceFilterer@或者派生@ErrorsViewStackTracePrinter@并在@grails-app/conf/spring/resources.groovy@ 中对其注册：

{code}
import com.yourcompany.yourapp.MyErrorsViewStackTracePrinter

beans = {

    errorsViewStackTracePrinter(MyErrorsViewStackTracePrinter,
                                ref('grailsResourceLocator'))
}
{code}

h3. 替代的日志库

Grails默认使用Log4J进行日志记录。对于大多数人而言这绝对没有问题，并且许多用户甚至不关心使用了什么日志库。但是如果你不是这些人中的一员并且想使用别的选择的话，例如[JDK日志包|http://download.oracle.com/javase/6/docs/api/index.html?java/util/logging/package-summary.html]或[logback|http://logback.qos.ch/]，通过简单地从全局依赖集合中排除几个依赖并添加你自己日志库的依赖你可以达成目标：

{code}
grails.project.dependency.resolution = {
    inherits("global") {
        excludes "grails-plugin-logging", "log4j"
    }
    ...
    dependencies {
        runtime "ch.qos.logback:logback-core:0.9.29"
        ...
    }
    ...
}

{code}

如果你这样做的话，在日志文件中你将得到未经过滤的、标准的Java栈跟踪并且你不能使用刚描述过的日志配置DSL。取而代之的是你将不得不使用你所选择的日志库的标准配置机制。
