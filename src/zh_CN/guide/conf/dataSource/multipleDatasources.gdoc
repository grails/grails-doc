缺省情况下，所有的领域类共享同一个DataSource和数据库，但是你还是有将领域类拆分到两个甚至更多个DataSource的选择的。

h4. 配置额外的数据源

缺省的DataSource配置是位于 @grails-app/conf/DataSource.groovy@ 中的，大体样子如下：

{code}
dataSource {
    pooled = true
    driverClassName = "org.h2.Driver"
    username = "sa"
    password = ""
}
hibernate {
    cache.use_second_level_cache = true
    cache.use_query_cache = true
    cache.provider_class = 'net.sf.ehcache.hibernate.EhCacheProvider'
}

environments {
    development {
        dataSource {
            dbCreate = "create-drop"
            url = "jdbc:h2:mem:devDb"
        }
    }
    test {
        dataSource {
            dbCreate = "update"
            url = "jdbc:h2:mem:testDb"
        }
    }
    production {
        dataSource {
            dbCreate = "update"
            url = "jdbc:h2:prodDb"
        }
    }
}
{code}

上述示例配置了一个Spring bean名称为dataSource的DataSource。要配置额外的DataSource，需要增加另外一个自定义名称（以下划线分割）的dataSource（跟标准的DataSource类似，只不过要定义在在最外层、环境代码块或者同时两个地方）代码块即可。例如，以下代码的配置新增了第二个DataSource，其在开发环境下是MySQL数据库，在生产环境下是Oracle：

{code}
environments {
    development {
        dataSource {
            dbCreate = "create-drop"
            url = "jdbc:h2:mem:devDb"
        }
        dataSource_lookup {
            dialect = org.hibernate.dialect.MySQLInnoDBDialect
            driverClassName = 'com.mysql.jdbc.Driver'
            username = 'lookup'
            password = 'secret'
            url = 'jdbc:mysql://localhost/lookup'
            dbCreate = 'update'
        }
    }
    test {
        dataSource {
            dbCreate = "update"
            url = "jdbc:h2:mem:testDb"
        }
    }
    production {
        dataSource {
            dbCreate = "update"
            url = "jdbc:h2:prodDb"
        }
        dataSource_lookup {
            dialect = org.hibernate.dialect.Oracle10gDialect
            driverClassName = 'oracle.jdbc.driver.OracleDriver'
            username = 'lookup'
            password = 'secret'
            url = 'jdbc:oracle:thin:@localhost:1521:lookup'
            dbCreate = 'update'
        }
    }
}
{code}

你可以使用Hibernate所支持的相同和或者相异的数据库。

h4. 配置领域类

如果一个领域类没有配置DataSource，那么其缺省使用标准的'dataSource'。你可以在mapping代码块中设置datasource属性来配置一个非标准的DataSource。例如，你希望ZipCode使用名为'lookup'的DataSource，其配置如下：

{code}
class ZipCode {

   String code

   static mapping = {
      datasource 'lookup'
   }
}
{code}

一个领域类还可以有两个甚至更多个DataSources。这时候，只需要将datasources设置为一个名称的列表即可，比如：

{code}
class ZipCode {

   String code

   static mapping = {
      datasources(['lookup', 'auditing'])
   }
}
{code}

如果一个领域类既使用缺省的又使用多于一个的DataSource，可以使用名称为'DEFAULT'来代表缺省的DataSource：

{code}
class ZipCode {

   String code

   static mapping = {
      datasources(['lookup', 'DEFAULT'])
   }
}
{code}

如果一个领域类要使用所有已经配置的DataSource，请使用特定名称'ALL'：

{code}
class ZipCode {

   String code

   static mapping = {
      datasource 'ALL'
   }
}
{code}

h4. 命名空间和GORM方法

如果一个领域类使用了多于一个的DataSource，你可以将其每个DataSource名称作为命名空间，并且以此命名来执行GORM的方法调用。例如，下面示例的类有两个DataSource：

{code}
class ZipCode {

   String code

   static mapping = {
      datasources(['lookup', 'auditing'])
   }
}
{code}

当没有明确指定命名空间的时候，其指定的第一个DataSource被视为缺省，上例中其缺省命名空间是'lookup'。但是你也可以在'auditing'的DataSource上执行GORM方法，比如：

{code}
def zipCode = ZipCode.auditing.get(42)
...
zipCode.auditing.save()
{code}

如你所见，你可以在DataSource上进行静态和实例类型的方法调用。

h4. Hibernate 映射领域类

你可以将Java类申明到不同数据源中。如果类使用默认数据源，那么他们就在 @grails-app/conf/hibernate/hibernate.cfg.xml@ 中注册。
对于特别不是默认的数据源申明类，那么按照数据源名作为 @hibernate.cfg.xml@ 的前缀。

例如， @Book@ 在一个默认数据源中，你可以注册它 @grails-app/conf/hibernate/hibernate.cfg.xml@:

{code:xml}
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
          '-//Hibernate/Hibernate Configuration DTD 3.0//EN'
          'http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd'>
<hibernate-configuration>
   <session-factory>
      <mapping class='org.example.Book'/>
   </session-factory>
</hibernate-configuration>
{code}

如果 @Library@ 在名为 "ds2" 的数据源中，你可以这样注册它 @grails-app/conf/hibernate/ds2_hibernate.cfg.xml@:

{code:xml}
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
          '-//Hibernate/Hibernate Configuration DTD 3.0//EN'
          'http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd'>
<hibernate-configuration>
   <session-factory>
      <mapping class='org.example.Library'/>
   </session-factory>
</hibernate-configuration>
{code}

这个过程映射是完全一样的，只是把它们放在对应的 hibernate.cfg.xml 文件中而已。

h4. 服务类

跟领域类相似，服务类也是使用缺省的DataSource和PlatformTransactionManager。要配置服务使用另外一个不同的DataSource，请使用静态的（static）datasource属性，比如：

{code}
class DataService {

   static datasource = 'lookup'

   void someMethod(...) {
      ...
   }
}
{code}

一个支持事务的服务只能使用一个DataSource，因此请确保领域类的DataSource的名字要跟服务类中定义的一致。

注意，一个服务类的datasource不对领域类的datasources产生影响，后者由其自身的声明决定。服务类的datasource多用来声明要使用哪一个事务管理器。

假设你有两个数据源，领域类Foo属于dataSource1，Bar属于dataSource2，而WahooService使用dataSource1，此外还有一个方法来实现Foo和Bar的新增保存，那么只有Foo是支持事务的，因为他们共享dataSource1数据源。而Bar实例并不受事务影响。如果你想两者都支持事务，那么你需要两个服务类和支持两阶段提交的XA数据源，比如使用Atomikos插件。

h4. 在多个数据源中实现事务 Transactions across multiple datasources 

Grails 使用  the Best Efforts 1PC pattern (1PC模式的最佳实现-译者注)来处理跨多个数据源处理事务。

1PC模式的最佳实现 [Best Efforts 1PC pattern|http://www.javaworld.com/article/2077963/open-source-tools/distributed-transactions-in-spring--with-and-without-xa.html?page=2] 是大都公平的，但在一些情况下可能失败，这个需要引起开发者注意。This is a non-XA pattern that involves a synchronized single-phase commit of a number of resources. Because the [2PC|https://en.wikipedia.org/wiki/Two-phase_commit] is not used, it can never be as safe as an [XA|https://en.wikipedia.org/wiki/X/Open_XA] transaction, but is often good enough if the participants are aware of the compromises.

The basic idea is to delay the commit of all resources as late as possible in a transaction so that the only thing that can go wrong is an infrastructure failure (not a business-processing error). Systems that rely on Best Efforts 1PC reason that infrastructure failures are rare enough that they can afford to take the risk in return for higher throughput. If business-processing services are also designed to be idempotent, then little can go wrong in practice.

BE1PC 在Grails 2.3.6版本被加入。. Before this change additional datasources didn't take part in transactions initiated in Grails. The transactions in additional datasources were basically in auto commit mode. In some cases this might be the wanted behavior. One reason might be performance: on the start of each new transaction, the BE1PC transaction manager creates a new transaction to each datasource. It's possible to leave an additional datasource out of the BE1PC transaction manager by setting @transactional = false@ in the respective configuration block of the additional dataSource. 含有 @readOnly = true@ 的数据源也将被排除在链式事务管理外(since 2.3.7)。 

By default, the BE1PC implementation will add all beans implementing the Spring @[PlatformTransactionManager|http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html]@ interface to the chained BE1PC transaction manager. For example, a possible @[JMSTransactionManager|http://docs.spring.io/spring/docs/3.2.x/javadoc-api/org/springframework/jms/connection/JmsTransactionManager.html]@ bean in the Grails application context would be added to the Grails BE1PC transaction manager's chain of transaction managers. 

You can exclude transaction manager beans from the BE1PC implementation with the this configuration option:
{code}
grails.transaction.chainedTransactionManagerPostProcessor.blacklistPattern = '.*'
{code}
The exclude matching is done on the name of the transaction manager bean. The transaction managers of datasources with @transactional = false@ or @readOnly = true@ will be skipped and using this configuration option is not required in that case.

h4. XA和两阶段（Two-phase）提交

When the Best Efforts 1PC pattern isn't suitable for handling transactions across multiple transactional resources (not only datasources), there are several options available for adding XA/2PC support to Grails applications.

[Spring transactions documentation|http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/transaction.html#transaction-application-server-integration] 包含一些关于 JTA/XA 在不同应用程序中的事务管理说明。In this case, you can configure a bean with the name @transactionManager@ manually in @resources.groovy@ or @resources.xml@ file.

这个 [Atomikos plugin|http://grails.org/plugin/atomikos] 能在Grails实现XA。